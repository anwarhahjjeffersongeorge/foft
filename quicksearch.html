<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"foft.js.html":{"id":"foft.js.html","title":"Source: foft.js","body":" Documentation Classes Foft Source: foft.js 'use strict' /** * @class Foft is a class that evaluates the * properties of Function or Foft objects that * generally receive and return objects of type * - Number * - Array of Number, * - Array of Array * @example * // returns a Foft instance * let MoT = new Foft() * @example * // returns a Foft instance that * // describes an equation over the range [0,1] (inclusive) * // split into 22 segments (23) total points * let MoT = new Foft({ * range: [0, 1], * segmentDivisor: 22, * terms: (t) =&gt; t*2; * }); * Foft also evaluates some of the properties * of the Function or Foft objects in its terms * @see Foft.oft */ class Foft { /** * create a Foft instance that evaluates its Function terms * when given some parameter \"t\". * * accepts an argument params that may be a(n): * - function see params.terms for details * - object see params for details * - array of numbers see params.range for details * - Foft instance will return a copy of the instance * * @param {(Object|Function|Array.&lt;Number&gt;|Foft)} params * @param {(Number|Array.&lt;Number&gt;)} [params.range] Range of two numerical values over which t is evaluated inclusively. If given a single number t0, range is [-t0,t0] * @param {Number} [params.segmentDivisor] The number of segments to divide the range into when picking t values for evaluation. * @param {(Function|Array.&lt;Function&gt;|Array.&lt;Foft&gt;)} [params.terms=[]] A function that accepts a parameter t and returns a result of some operation on t * @param {boolean} [params.rangeoverride=false] if true, will override any range provided and set range equal to [0, params.segmentDivisor] * @param {boolean} [params.harmonize=false] if true, will harmonize the domains of any Foft terms to that of the new parent instance @see range, @see segmentDivisor * @throws TypeError */ constructor (params) { params = params || {} if (typeof params === 'function') { let thefunc = params params = { terms: thefunc } } else if (Foft.ISARRAYLIKE(params)) { let thearray = params params = { range: thearray } } else if (params instanceof Foft) { let thefoft = params let { segmentDivisor, range, terms } = thefoft params = { segmentDivisor, range: Array.from(range), terms: Array.from(terms) } } // define the division of the evaluation range const segmentDivisor = params.segmentDivisor || Foft.DEFAULT_SEGMENT_DIVISOR this.segmentDivisor = segmentDivisor let rangeoverride = (typeof params.rangeoverride === 'boolean') ? params.rangeoverride : false let harmonize = (typeof params.harmonize === 'boolean') ? params.harmonize : false // create an evaluation range let range = (rangeoverride) ? [0, this.segmentDivisor] : params.range || Foft.DEFAULT_RANGE range = Foft.ISCALCULABLE(range) ? [-range, range] : range if (!Foft.ISARRAYLIKE(range)) throw new TypeError('range should be array') // if(range.length!==2) throw new RangeError('range should have two elements') this.range = Array.from(range) // this Foft can use these terms // define terms this._terms = [] let terms = params.terms || [(t) =&gt; t] terms = (typeof terms === 'function') ? [terms] : terms if (!Foft.ISARRAYLIKE(terms) &amp;&amp; (typeof terms !== 'function') &amp;&amp; !(terms instanceof Foft)) { throw new TypeError('params.terms should be array, function or Foft instance') } for (let term of terms) { // const term = terms[termIndex]; // console.log(term);`` this.addTerm(term, harmonize) } // console.log(params.opcode) // debugger; this.opcode = params.opcode } /** * the Function terms of this Foft object * * @return {Array} */ get terms () { return this._terms } /** * add a term to the terms of this Foft instance * * @param {(function|Foft)} term A Function that takes a parameter (t) or * Foft * @param {boolean} [harmonize=false] if true, and term is a Foft * instance, this overwrites the range and segmentDivisor of term to make them * reference the same-named parameters of this instance. * @returns {boolean} true if length of terms grew */ addTerm (term, harmonize) { let numterms = this.terms.length const push = (_term) =&gt; { this.terms.push(_term) this[numterms] = this.terms[numterms] } harmonize = (typeof harmonize === 'boolean') ? harmonize : false if (typeof term === 'function' &amp;&amp; !(term instanceof Foft)) { push(term) } else if (term instanceof Foft) { push(term) if (harmonize) { // term.range = this.range; // term.segmentDivisor = this.segmentDivisor; const keys = ['_range', '_segmentDivisor'] for (let key of keys) { Object.defineProperty(term, key, { get: () =&gt; this[key], // reference to parent set: (value) =&gt; Object.defineProperty(term, key, { value })// dareference from parent }) } } } return numterms === this.terms.length - 1 } /** * set segmentDivisor - set the segment divisor for the evaluation range where * - the range will be divided into (segmentDivisor+1) segments, * - if given an arraylike parameter, use the 0th value * - if given a calculable parameter, use it as-is * * * @param {number|arraylike&lt;number&gt;} segmentDivisor * @throws {TypeError} segmentDivisor should be calculable number */ set segmentDivisor (segmentDivisor) { segmentDivisor = Foft.ISARRAYLIKE(segmentDivisor) ? segmentDivisor[0] : segmentDivisor if (!Foft.ISCALCULABLE(segmentDivisor)) { // console.log('NaN segment Divisor') throw new TypeError('segmentDivisor should be calculable number, not: ' + segmentDivisor) } else { this._segmentDivisor = [segmentDivisor] } } /** * get segmentDivisor The number of segment divisors * (number of t evaluation points -1) * in this Foft * * @return {Number} */ get segmentDivisor () { return this._segmentDivisor[0] } /** * The number of actual segments the Foft divides the evaluation range into * * @return {Number} */ get numSegments () { return this.segmentDivisor + 1 } /** * get the delta for t between the first and final values of the * evaluation range. May be innacurate when the range has more than two * terms * * @return {number} */ get dt () { return this.drange / this.segmentDivisor } /** * set range - only accepts an arraylike of calculables * * @param {Array&lt;number&gt;} range */ set range (range) { if (!(Foft.ISARRAYLIKE(range) &amp;&amp; Foft.ARECALCULABLES(range))) throw new TypeError('range values should be Array of calculable numbers') this._range = Array(range.length) for (let rangeIndex in range) { this._range[rangeIndex] = range[rangeIndex] } } /** * get the evaluation range is the minimum and maximum values for t * * @return {Array.&lt;Number&gt;} */ get range () { return this._range } /** * get the first value of t in the evaluation range T * @see T * @return {Number} */ get t0 () { return this.range[0] } /** * the last value of t in the evaluation range T * @see T * @return {Number} */ get tt () { return this.range[this.range.length - 1] } /** * a Foft can have an opcode as defined in * Foft.OPS. These codes represent mathematical operations * between Numbers and other types. They are useful for performing * said operations when the Function or Foft in the terms * Array * * @see Foft.OPS * @see terms * @return {string} @see Foft.OPS */ get opcode () { return this._opcode } /** * set opcode - set the opcode to one of the opcodes * defined in Foft.OPS * * @param {string} [opcode=null] @see Foft.OPS */ set opcode (opcode) { this._opcode = (Foft.ISOP(opcode)) ? opcode : null } /** * given indices n &amp; nn * returns the delta between sub values in the Foft instance's * evaluation range, or: range[nn%range.length]-range[n%range.length], * * when given no parameters, it uses 0 and 1 * * @param {Number} [n=0] the starting range index. * @param {Number} [nn=n+1%this.range.length] the end range index * @return {Number} * @throws {TypeError} when given non-number parameter */ dSubrange (n, nn) { n = Foft.ISNUMBER(n) ? n : 0 if (nn &amp;&amp; !Foft.ISNUMBER(nn)) { throw new TypeError(`Foft.dSubRange only accepts Numbers, given ${[...arguments]}`) } n = n % this.range.length if (!Number.isInteger(n)) { throw new RangeError(`Foft.dSubRange only accepts Integers, given ${[...arguments]}`) } // for this conditional, we use the explicit ISNUMBER to avoid logical // error for zero case: if(0) is falsy nn = Foft.ISNUMBER(nn) ? nn % this.range.length : (n + 1) % this.range.length if (!Number.isInteger(nn)) { throw new RangeError(`Foft.dSubRange only accepts Integers, given ${[...arguments]}`) } return this.range[nn] - this.range[n] } /** * the delta between the the first and final values of the evaluation range * * @return {Number} */ get drange () { return this.range[this.range.length - 1] - this.range[0] } /** * the absolute value of the delta * between the first and final values of the evaluation range * * @return {Number} */ get dabsrange () { return Math.abs(this.drange) } /** * get a generator function that yields segmentDivisor+1 values of t spanning the range [this.range[n], this.range[n+1]], where if n or n+1 fall beyond the bounds of this.range.length, they are constrained to fit * * @param {Number} [n=0] integer start index of range * * @return {type} description */ subT (n, omitLast) { omitLast = (typeof omitLast === 'boolean') ? omitLast : false let defaultN = 0 n = Foft.ISNUMBER(n) ? n % this.range.length : defaultN let a = this.range[n] let b = this.range[(n + 1) % this.range.length] let tsubmax = (omitLast) ? this.segmentDivisor - 1 : this.segmentDivisor let dt = (b - a) / this.segmentDivisor /** * @yields {Number} */ return function * () { for (let tsubindex = 0; tsubindex &lt;= tsubmax; tsubindex++) { yield a + tsubindex * dt } } } /** * get a Generator yielding all values of t across instance evaluation range * @example * // get the default t values for which a Foft is * // evaluated * let MoT = new Foft({ * range: [0, Math.PI*2], * segmentDivisor: 22, * terms: (t) =&gt; [sin(t), cos(t)]; * }); * let T = [...MoT.T()] * @return {Generator&lt;Number&gt;} */ get T () { let rangelimit = this.range.length - 2 /** * @yields {Number} */ return function * () { for (let rangeIndex = 0; rangeIndex &lt;= rangelimit; rangeIndex++) { yield * (rangeIndex === rangelimit) ? this.subT(rangeIndex)() : this.subT(rangeIndex, true)() // chop last to eliminate double values } } } /** * given a Number t, return a normalized (to Foft.DEFAULT_RANGE) * representation of the ratio between t and the delta of the evaluation * range of this Foft * * If t falls out of bounds of range, the value is returned as -/+ Infinity * * If the evaluation range has more than two values, e.g. [0,1,2], * then normalizeT checks in each subrange, e.g. [0,1], [1,2] * and returns an Array of normalized values corresponding to each range * * @see NORMALIZETORANGE * @see DEFAULT_RANGE * @param {Number} [t=0] * @param {boolean} [doAnti=false] * @return {Number|Array&lt;Number&gt;} */ normalizeT (t, doAnti) { doAnti = (typeof doAnti === 'boolean') ? doAnti : false let func = (doAnti) ? Foft.ANTINORMALIZETORANGE : Foft.NORMALIZETORANGE let arr = Array(this.range.length - 1) for (let r = 0; r &lt; arr.length; r++) { arr[r] = func(t, [ this.range[r], this.range[r + 1] ]) } return (arr.length === 1) ? arr[0] : arr } /** * given a number t return a normalized representation of the ratio of a quantity n to the delta of the instance evaluation range such that the ratio of t to the delta of the evaluation range N satisfies * 1.n = maximum normal - N * * This is the remaining range for the normalized value provided by normalizeT * * if t falls beyond the lower bound of the evaluation range, return +Infinity * if t falls beyond the upper bound of the evaluation range, return -Infinity * * @see normalizeT * @param {number} t * @return {number} n */ antinormalizeT (t) { return this.normalizeT(t, true) } /** * given a Number t within a the evaluation range of this instance * (inclusive), return the value of the corresponding i such that * 1. i is proportional to the location of t within the range * 2. i is scaled to segmentDivisor * * If t falls out of bounds of the range, nothing is returned * * If the range has more than two elements, return an array of length range-1 * @see IINRANGE * @see segmentDivisor * @see normalizeT * @param {Number} t * @return {Number|null|Array&lt;number|null&gt;} [0, segmentDivisor] */ i (t) { let arr = Array(this.range.length - 1) for (let r = 0; r &lt; arr.length; r++) { arr[r] = Foft.IINRANGE(t, [ this.range[r], this.range[r + 1] ], this.segmentDivisor) } return (arr.length === 1) ? arr[0] : arr } /** * return true IFF a given t falls within the evaluation range of this instance * * @param {number} t * @return {boolean} */ isInRange (t) { return Foft.INRANGE(t, this.range) } /** * evaluate all of the terms held by this Mathoft for the * given t value. * * When evaluating a Function or Foft term, the function or Foft is called with a this object containing certain useful data regarding the calling instance's evaluation of t @see TTHIS_TEMPLATE * * When evaluating a Foft term, any t that falls outside that term's evaluation range will produce a null result. If the filterNulls parameter is true, then null values will be stripped from the returned result. * @see isInRange * @param {Number} [t=t0] * @param {boolean} [filterNulls=false] * @param {boolean} [maketthis=true] * @return {(Number|Array.&lt;Number&gt;|Array&lt;Array&gt;)} */ oft (t, filterNulls, maketthis) { // console.log(this) t = Foft.ISCALCULABLE(t) ? t : this.t0 filterNulls = (typeof filterNulls === 'boolean') ? filterNulls : false maketthis = (typeof maketthis === 'boolean') ? maketthis : true // debugger; let tthis = (maketthis) ? Foft.TTHIS_TEMPLATE(t, this) : (typeof this.tthis === 'object') ? this.tthis : null let result = [] for (let i in this.terms) { let _term = this.terms[i] if (typeof _term === 'function') { result[i] = _term.call(tthis, t) } else if (_term instanceof Foft) { // console.log(_term); let subres = _term.isInRange(t) ? _term.oft.call(Object.assign(_term, { tthis }), t, null, false) : null result[i] = subres // OVERRIDE? } } result = (filterNulls) ? result.filter((v) =&gt; v) : result return (result.length === 1) ? result[0] : result } /** * return the oft for the first t in the evaluation range * * @see t0 * @see oft * @return {(Number|Array.&lt;Number&gt;|Array.&lt;Array&gt;)} */ get ofFirstt () { return this.oft(this.t0) } /** * return the oft for the final t in the evaluation range * * @see range * @see oft * @return {(Number|Array.&lt;Number&gt;|Array.&lt;Array&gt;)} */ get ofLastt () { return this.oft(this.tt) } /** * Accepts a Number tNormal that falls within Foft.DEFAULT_RANGE, inclusive, and when provided * 1 . A NaN value, return NaN * 2. +Infinity, returns evaluation from end bound of range * 3. -Infinity, returns evaluation from start bound of range * 4. Any other number even outside of normal range, returns value of that t. * * @see ISCALCULABLE * @see ofFirstt * @see ofLastt * @see DEFAULT_RANGE * @see oft * @param {Number} [tNormal=[-1,1]] * @return {(Number|Array.&lt;Number&gt;)} */ oftNormal (tNormal) { let dNormal = Foft.DEFAULT_RANGE[1] - Foft.DEFAULT_RANGE[0] let midNormal = Foft.DEFAULT_RANGE[0] + dNormal / 2 tNormal = Foft.ISNUMBER(tNormal) ? tNormal : midNormal let t; let midt = (this.tt - this.t0) / 2 + this.t0 if (Foft.ISCALCULABLE(tNormal)) { t = midt + (tNormal - midNormal) * this.drange / 2 } // debugger; return (t !== undefined) ? this.oft(t) : (Number.isNaN(tNormal)) ? NaN : tNormal === -Infinity ? this.ofFirstt : this.ofLastt } /** * Calculate the value of performing an operation _op on the * values returned by calculating this Foft instance's terms for * some evaluation value t. When given a parameter _acc, the calculation of _op will use _acc as its starting value. * * This is intended to facilitate convenient manipulation of terms and results. * * @see oft * * @param {Number} t the t to evaluate * @param {string} [_op=this.opcode] an opcode to perform @see Foft.OPS * @param {(Number|Array.&lt;Number&gt;|Array.&lt;Array&gt;)} [_acc=null] an accumulator value to start with @see Foft.OPS -&gt; base * @return {(Number|Array.&lt;Number&gt;|Array.&lt;Array&gt;)} */ oftOp (_t, _op, _acc) { _op = (_op in Foft.OPS) ? _op : this.opcode const op = Foft.OPS[_op] // debugger; _acc = ((_acc || Number.isNaN(_acc))) ? (Foft.ARENUMBERS(_acc)) ? _acc : NaN : null // op.base // debugger; const transform = (acc, val) =&gt; { let transformRes // console.log(acc,val); switch (Foft.MATHTYPEOF(val)) { case Foft.MATHTYPES.numberlike: if (Foft.ISARRAYLIKE(acc)) { throw new TypeError('Can\\'t apply an arraylike accumulator to a scalar.') } else if (Foft.ISNUMBER(acc)) { transformRes = op(acc, val) } break case Foft.MATHTYPES.arraylike: let isNested = Foft.ISARRAYLIKE(val[0]) if (Foft.ISARRAYLIKE(acc)) { if (acc.length !== val.length) { let areMismatched = (isNested) ? acc.length !== val[0].length : true if (areMismatched) { throw new TypeError('Can\\'t apply an op to arraylike values of dissimilar lengths.') } } if (isNested) { return val.reduce(transform, acc) } else { for (let i = 0; i &lt; val.length; i++) { val[i] = transform(acc[i], val[i]) // overwrite in place } } } else if (Foft.ISNUMBER(acc)) { for (let i = 0; i &lt; val.length; i++) { val[i] = transform(acc, val[i]) // overwrite in place } } transformRes = val break } return transformRes } let _oft = this.oft(_t) // if (!_op) { return op(_oft) } // console.log(_oft) // console.log(_acc); let res switch (this.terms.length) { case 1: res = (_acc || Number.isNaN(_acc)) ? transform(_acc, _oft) : _oft break default: res = (_acc || Number.isNaN(_acc)) ? Foft.ISARRAYLIKE(_acc) ? transform(_acc, _oft) : _oft.reduce(transform, _acc) : _oft.reduce(transform) break } return res } /** * get a Generator that yields * all Array=[t, this.oft(t)] for t in evaluation range * in form [t, this.oft(t)] * * @see oft * @return {Generator} */ get ofAlltT () { return function * () { for (let t of [...this.T()]) { yield [ t, this.oft(t) ] } } } /** * Symbol.iterator get a Generator that yields * all this.oft(t) for t in evaluation range * @see oft * @return {Generator} Generator function yielding this.oft(t) */ get [Symbol.iterator] () { return function * () { yield * [...this.T()].map((t, i) =&gt; this.oft(t)) } } /** * get a Generator that yields all * this.oftOp(_t, _acc, _op) for _t in T, * _acc, _op provided by user * * @see ofAlltTOp * @return {Generator} description */ get ofAlltTOp () { return function * (_acc, _op) { yield * [...this.T()].map((_t) =&gt; this.oftOp(_t, _op, _acc)) } } /** * apply the Array.map native function to the elements yielded by * this[Symbol.iterator] with the given callback function and this argument * * * @see get [Symbol.iterator] * @param {Function} [callback] callback to apply * @param {Object} [thisArg] this argument * @return {Array} map result */ mapT (callback, thisArg) { if (!(callback instanceof Function)) throw new TypeError('map needs Function callback') return [...this].map(callback, thisArg) } /** * apply the Array.map native function to the elements of * this.ofAllTOp() with the given callback function and this argument * @see Array.map * @see ofAllTOp * @param {Function} [callback] callback to apply * @param {Object} [thisArg] this argument * @return {Array} map result */ mapTOp (callback, thisArg) { if (!(callback instanceof Function)) throw new TypeError('map needs Function callback') return [...this.ofAlltTOp()].map(callback, thisArg) } /** * toString * * @override * @return {string} */ toString () { let res = 'Foft\\n' res += `range:\\n\\t[${this.range}]\\n` res += `segments:\\n\\t[${this.numSegments}]\\n` res += `terms:\\n` for (var i = 0; i &lt; this.terms.length; i++) { res += `\\t[${i}]: ${this.terms[i]}\\n` } res += `opcode:\\n\\t${this.opcode}` return res } /** * get Symbol.toStringTag * * @override * @return {string} */ get [Symbol.toStringTag] () { return 'Foft Function' } /** * give precision warning in the form of an object that can be converted to a primitive. * * Floating point math has inherent imprecisions. This function is useful for quantifying them and identifying potentially problematic operations. It uses a few different tests to highlight sources of error, including: * 1. a*\\frac{1}{a} // Multiplicative Identity * 2. \\sum_{i=1}^{a} 1/a // Sum of Inverses * @return {object} the object with primitive values: * {number} the maximum value for which no precision is lost * {string} as brief message * @static */ static CALC_PRECISION_WARN (maxtestnum) { let res let getmsg = (e) =&gt; `Maximum safe unit divisor: ${e}` let tests = [ (a) =&gt; ((1 / a) * a === 1), // multiplicative identity (a) =&gt; Array(a).fill(1 / a).reduce((acc, val) =&gt; acc + val, 0) // sum of inverses ] // only do so many tests let testnum = 0 const maxtest = Foft.ISCALCULABLE(maxtestnum) ? maxtestnum : 144 // tests[0] let lastgoodmultidendivisor, msg // tests[1] let roundinaccura = [] // all divisors for which rounding error causes failure let rounddeltas = [] // the difference between erroneous rounding and 1 let roundexcesses = [] // divisors for which rounding error causes excess failure let rounddeficits = [] // divisors for which rounding error causes deficiency failure while (testnum &lt; maxtest) { // tests[0] if (!tests[0](++testnum)) { lastgoodmultidendivisor = testnum - 1 msg = getmsg(lastgoodmultidendivisor) } // tests[1] const test1result = tests[1](testnum) // testnum has been incremented already if (test1result !== 1) { roundinaccura.push(testnum) rounddeltas.push(test1result - 1) if (test1result &lt; 1) rounddeficits.push(testnum) if (test1result &gt; 1) roundexcesses.push(testnum) } }; res = { [Symbol.toPrimitive]: (hint) =&gt; { if (hint === 'number') return lastgoodmultidendivisor return msg }, inaccurateDivisors: { all: roundinaccura, errors: rounddeltas, excessive: roundexcesses, deficient: rounddeficits }, [Symbol.iterator]: function * () { yield * roundinaccura } } return res } /** * return true IFF both of the following conditions are met * 1. there was ONE argument provided, and * 2. the sole provided argument was a Number * * * @return {boolean} * @static */ static ISNUMBER () { return (arguments.length === 1) &amp;&amp; (typeof arguments[0] === 'number') } /** * return true IFF all of the following conditions are met * 1. argument satisfies ISNUMBER (One Number argument) * 2. argument is not NaN * 3. argument is not +/-Infinity * * This function does more calls than just using isFinite, however, it is used in the Foft class because the class also deals with arrays and objects. * * @see ISNUMBER * * @return {boolean} description * @static */ static ISCALCULABLE () { return (arguments.length === 1) &amp;&amp; Number.isFinite(arguments[0]) } /** * determine whether a given argument x is \"like\" an array for the purposees of Foft calculations and parsing, returning true IFF x satisfies one of the following conditions: * 1 - It is an Array * 2 - It is a TypedArray * 3 - It provides a Symbol.iterator property * * The third condition allows for the parsing of various iterable objects, but it does not guarantee that such actions will produce calculable values. * * @param {?} x * @return {boolean} * @static */ static ISARRAYLIKE (x) { return x &amp;&amp; (Object.getOwnPropertySymbols(x).includes(Symbol.iterator) || Array.isArray(x) || ArrayBuffer.isView(x)) } /** * ARENUMBERS return true IFF one of these conditions are met * 1. The provided arguments are ALL of Number type, * 2. The sole provided argument is an Array whose members are ALL of Number type, * 3. Any provided argument is an Array whose members are * A. ALL of Number type, or * B. nested Arrays whose submembers are all number types or Arrays * and ALL other arguments are Number type or Array with ALL members of Number type, * * @see ARECALCULABLES * * @params {} [arguments] figure out whether the arguments are numbers or * an Array thereof * @return {boolean} * @static */ static ARENUMBERS () { if (arguments.length === 0) { return false } else { return [...arguments].every(v =&gt; { return Foft.ISARRAYLIKE(v) ? Foft.ARENUMBERS(...v) : Foft.ISNUMBER(v) }) } }; /** * ARECALCULABLES return true IFF one of these conditions are met * 1. The provided arguments are ALL of Number type, * 2. The sole provided argument is an Array whose members are ALL of Number type, * 3. Any provided argument is an Array whose members are * A. ALL of Number type, or * B. nested Arrays whose submembers are all number types or Array, * and ALL other arguments are Number type or Array with ALL members of Number type, and * 4. All arguments of number type are neither NaN nor -/+Infinity * * @see ARENUMBERS * * @params {} [arguments] figure out whether the arguments are numbers or * an Array thereof * @return {boolean} * @static */ static ARECALCULABLES () { if (arguments.length === 0) { return false } else { return [...arguments].every(v =&gt; { return Foft.ISARRAYLIKE(v) ? Foft.ARECALCULABLES(...v) : Foft.ISCALCULABLE(v) }) } }; /** * determine whether a given number n falls * within any of the follwoing inclusive ranges * 0. [ Foft.DEFAULT_RANGE[0], Foft.DEFAULT_RANGE[1] ] * 1. [0, m], * 2. [0, m[0]], (when provided unit-length array) * 3. [m[0], m[m.length-1]] * 4, [m, mm] * * @param {Number} n the number to test * @param {(Number|Array&lt;Number&gt;)} [m] the end of the range starting with 0, or * the Array representing the range [m[0], m[last]] * the begining of range ending in mm, or * @param {Number} [mm] the optional end of the range * @return {boolean} * @static */ static INRANGE (n, m, mm) { let test = (a, b, c) =&gt; { // console.log(a,b,c) return (a &gt; b) ? a &lt;= c : (a &lt; b) ? a &gt;= c : true // a === b } if (!(Foft.ARENUMBERS(...arguments) &amp;&amp; Foft.ISNUMBER(n))) { return false } else { if (arguments.length === 1) { return Foft.INRANGE(n, Foft.DEFAULT_RANGE) } else if (Foft.ISARRAYLIKE(m)) { // console.log(n,m) return (m.length === 1) ? test(n, 0, m[0]) : test(n, m[0], m[m.length - 1]) } else if (Foft.ISNUMBER(m)) { if (!Foft.ISNUMBER(mm)) { return test(n, 0, m) } else if (Foft.ISNUMBER(mm)) { return test(n, m, mm) } } } } /** * given a Number t, amd a ramge TT, return a normalized (to an optional range NN or Foft.DEFAULT_RANGE) * representation of the ratio between the two deltas A and B where * 1. A is the difference betewen t and TT[first] * 2. B is the difference between TT[last] and TT[first] * * * If t falls out of bounds of range, the value is returned as -/+ Infinity, * where: * 1. -Infinity corresponding to beyond the bound of TT[first], and * 2. +Infinity corresponding to beyond the bound of TT[last] * * * @param {number} [t=0] the t to evaluate * @param {Array&lt;number&gt;} [TT=DEFAULT_RANGE] the range in which to test for TT * @param {Array&lt;number&gt;} [NN=DEFAULT_RANGE] the target normalization range * @return {number} * @static */ static NORMALIZETORANGE (t, TT, NN) { if (!Foft.ISNUMBER(t)) { t = 0 } if (!Foft.ARENUMBERS(NN)) { NN = Foft.DEFAULT_RANGE } if (!Foft.ARENUMBERS(TT)) { TT = Foft.DEFAULT_RANGE } let [normA, normB] = NN let minNorm = (normA &lt; normB) ? normA : normB // let maxNorm = (normB &gt; normA) // ? normB // : normA let res = (t - TT[0]) / (TT[1] - TT[0]) // [0-1] res = normA + (normB - normA) * res // [normA, normB] if (!Foft.INRANGE(res, normA, normB)) { res = (res &lt; minNorm) ? -Infinity : Infinity } return res } /** * given a Number t, amd a ramge TT, return a normalized (to Foft.DEFAULT_RANGE) * representation of the ratio between the two deltas A and B where * 1. A is the difference betewen t and TT[last] * 2. B is the difference between TT[last] and TT[first] * * If t falls out of bounds of range, the value is returned as -/+ Infinity, * where: * 1. +Infinity corresponding to beyond the bound of TT[first], and * 2. -Infinity corresponding to beyond the bound of TT[last] * * @see NORMALIZETORANGE * @param {number} [t=0] the t to evaluate * @param {Array&lt;number&gt;} [TT=DEFAULT_RANGE] the range in which to test for TT * @return {number} * @static */ static ANTINORMALIZETORANGE (t, TT, NN) { if (!Foft.ISNUMBER(t)) { t = 0 } if (!Foft.ARENUMBERS(TT)) { TT = Foft.DEFAULT_RANGE } if (!Foft.ARENUMBERS(NN)) { NN = Foft.DEFAULT_RANGE } let res = Foft.NORMALIZETORANGE(t, TT, NN) return (Math.abs(res) === Infinity) ? -res : NN[NN.length - 1] - res } /** * given a number t, a range TT and a divisor d, return the value of the corresponding i such that * 1. i is proportional to the location of t within the range * 2. i is proportional to d * * @param {number} t t to find in TT * @param {Array&lt;number&gt;} TT range * @param {type} d divisor * @return {null|number} * @static */ static IINRANGE (t, TT, d) { d = (Foft.ISNUMBER(d)) ? Math.floor(d) : Math.floor(Foft.DEFAULT_SEGMENT_DIVISOR) let res = Foft.NORMALIZETORANGE(t, TT, [0, 1]) return (res === Infinity) ? null : (res === -Infinity) ? null : Math.floor(res * d) } /** * return the size of the given x, where x can be a number or an arraylike or a nested arraylike * * @param {(number|Array)} x the structure to get dimensions of * @return {Array} * @static */ static DIMENSIONS (x) { let dim = Promise.resolve([]) if (Foft.ISNUMBER(x)) { return dim.then(dimarr =&gt; dimarr.concat(0)) } else if (Foft.ISARRAYLIKE(x)) { if (x.length === 0) { return dim.then(dimarr =&gt; dimarr.concat(0)) } else { let subarrayIndices = [] let isNotSubarrayTest = (acc, v, i) =&gt; { if (!Foft.ISARRAYLIKE(v)) { return acc &amp;&amp; true } else { subarrayIndices.push(i) return acc &amp;&amp; false } } if (x.reduce(isNotSubarrayTest, true)) { return dim.then(dimarr =&gt; dimarr.concat(x.length)) } else { return dim.then(dimarr =&gt; { return Promise.all(subarrayIndices.map((v) =&gt; { let xSubArr = x[v] // console.log(xSubArr) return Foft.DIMENSIONS(xSubArr) })).then(subdims =&gt; { // console.log(subdims, x.length) let flatsubdims = Foft.OPS['...'](subdims) // console.log(flatsubdims, x.length) let mag if (Foft.EQUAL(flatsubdims.length, subdims.length, x.length)) { mag = Foft.OPS.magest(...flatsubdims) } else { mag = Foft.OPS.magest(...subdims) } // mag = (Number.isNaN(mag) || mag === 0) // ? [] // : mag return dimarr.concat(x.length, mag) }) }) } } } return dim } /** * determine whether the given number or Array-like arguments are satisfying the conditions: * 1) all of a single shared type, * 2) if numbers, of equal value, * 3) if arrays, composed of equal positional elements * 4) if other types, satisfying strict equality test * * When comparing values that are NaN or containing NaN in the same positions, the function will return false because NaN doesn't equal NaN * * @params {?} [arguments] * @return {boolean} * @static */ static EQUAL () { if (arguments.length === 0) { return false } if (arguments.length === 1) { return !Number.isNaN(arguments[0]) } const a0 = arguments[0] const a0type = Foft.MATHTYPEOF(a0) let res = true // const dim = Foft.DIMENSIONS(arguments[0]); for (let i = 1; i &lt; arguments.length; i++) { let a = arguments[i] if (Foft.MATHTYPEOF(a) !== a0type) return false switch (a0type) { case Foft.MATHTYPES.arraylike: if (a.length !== a0.length) return false for (let ai = 0; ai &lt; a0.length; ai++) { if (!Foft.EQUAL(a0[ai], a[ai])) return false } break case Foft.MATHTYPES.numberlike: res = res &amp;&amp; (a === a0) break default: // console.log(a) res = res &amp;&amp; (a === a0) } } return res } /** * tell whether the given argument a is of one of the types that Foft can do math with and if so, which type * * @param {?} [a] * @return {(Symbol|null)} * @static */ static MATHTYPEOF (a) { return Foft.ISARRAYLIKE(a) ? Foft.MATHTYPES.arraylike : Foft.ISNUMBER(a) ? Foft.MATHTYPES.numberlike : null } /** * given a t and a Foft instance, produces an object with some keys for inter-instance communication corresponding to: * 1 the result of evaluating certain methods of the calling instance for t @see FUNCKEYS * 2 certain members of the calling instance @see MEMBERKEYS * * @see oft * @param {Number} t the t of the instance communicatiing * @param {Foft} foft the instance doing communication * @return {object|Array&lt;string&gt;} communication object, or array of communication keys * @static */ static TTHIS_TEMPLATE (t, foft) { let o = (Foft.ISCALCULABLE(t)) ? { t } : { } let populateFunc = (foft instanceof Foft) &amp;&amp; (Foft.ISCALCULABLE(t)) ? (key) =&gt; { o[key] = foft[key](t) } : () =&gt; null let populateMemb = (foft instanceof Foft) ? (key) =&gt; { o[key] = foft[key] } : () =&gt; null Foft.FUNCKEYS.map(fkey =&gt; populateFunc(fkey)) Foft.MEMBERKEYS.map(mkey =&gt; populateMemb(mkey)) if (Object.keys(o).length === 0) { return Foft.FUNCKEYS.concat(Foft.MEMBERKEYS) } else { return o } }; /** * given a string codeToParse, return true when code is found * in Foft.OPDICT * @see Foft.OPDICT * @param {string} codeToParse * @return {boolean} * @static */ static ISOP (codeToParse) { return Foft.OPDICT.includes(codeToParse) } /** * given a string codeToParse, return * the corresponding operation function from Foft.OPS * * @see Foft.OPS * @param {string} codeToParse * @return {function} Foft.OPS function corresponding to op * @static */ static OPPARSE (codeToParse) { return (Foft.ISOP(codeToParse)) ? Foft.OPS[codeToParse] : Foft.OPS[null] } } Object.defineProperties(Foft, { /** * valid types that Foft can do math on * @see Foft.MATHTYPEOF * @memberof Foft * @static */ 'MATHTYPES': { value: (() =&gt; { let o = {}; [ 'arraylike', 'numberlike' ].map(function (e) { this[e] = Symbol(e) this[this[e]] = e }, o) return o })(), enumerable: true, configurable: false, writable: false }, /** * an array of valid op keys * @see Foft.OPS * @memberof Foft * @static */ 'OPDICT': { value: [null, '+', '-', '*', '/', '**', '...', 'magest', 'magesti'], enumerable: true, configurable: false, writable: false }, /** * OPS an object containing operations, or ops, that * perform mathematical functions corresponding to their keys * @see Foft.ISOP * @see Foft.OPDICT * @see Foft.OPPARSE * @see Foft.ARENUMBERS * @memberof Foft * @static */ 'OPS': { value: Object.defineProperties({}, { 'opfunc': { value: (code, f) =&gt; { if (typeof code !== 'string') { throw new TypeError('Foft.OPS.opfunc takes one string') } else if (!Foft.OPDICT.includes(code)) { throw new RangeError('Foft.OPS.opfunc takes one string in Foft.OPDICT') } return (args) =&gt; [...args].reduce((acc, c, i) =&gt; f(acc, c)) }, writable: false, configurable: false, enumerable: false }, 'resfunc': { value: (code, f, base, args) =&gt; { if (!Foft.ISCALCULABLE(base)) { throw new TypeError('Foft.OPS.resfunc requires a calculable base parameter') } if (!Foft.ISARRAYLIKE(args)) { throw new TypeError('Foft.OPS.resfunc requires an iterable, Array or ArrayBuffer view args parameter') } if (Foft.ARENUMBERS(...args)) { return Foft.OPS.opfunc(code, f)(args) } let nullsReplaced = [...args].map(v =&gt; (v === null) ? base : v) if (Foft.ARENUMBERS(nullsReplaced)) { return Foft.OPS.opfunc(code, f)(nullsReplaced) } return NaN }, writable: false, configurable: false, enumerable: false }, [null]: { enumerable: true, value: (() =&gt; { let code = null let base = null let desc = 'null op' return Object.assign( function (...args) { return args }, { code, base, desc } ) })(), configurable: false, writable: false }, '+': { enumerable: true, value: (() =&gt; { let base = 0 let code = '+' let desc = 'summation' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a + b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, '-': { enumerable: true, value: (() =&gt; { let base = 0 let code = '-' let desc = 'subtraction' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a - b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, '*': { enumerable: true, value: (() =&gt; { let base = 1 let code = '*' let desc = 'multiplication' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a * b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, '/': { enumerable: true, value: (() =&gt; { let base = 1 let code = '/' let desc = 'division' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a / b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, '**': { enumerable: true, value: (() =&gt; { let base = 1 let code = '**' let desc = 'exponentiation' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a ** b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, /** * ... recursive arraylike flatten. given parameter arr, return * - if arr is arraylike, a 1-d Array containing the elements of arr with their order preserved, or * - if arr isn't arraylike, arr * @memberof Foft#OPS * @param {arraylike} arr * @return {arraylike|?} */ '...': { enumerable: true, value: (() =&gt; { let code = '...' let base = [] let desc = 'flatten' return Object.assign( function flatten (arr) { if (!Foft.ISARRAYLIKE(arr)) { return arr } else { return arr.reduce((acc, v) =&gt; { return (Foft.ISARRAYLIKE(v)) ? acc.concat(flatten(v)) : acc.concat(v) }, base) } }, { code, base, desc } ) })(), configurable: false, writable: false }, /** * @name magest - given some * - calculable values, return the one with the greatest MAGNITUDE * - arraylike values, return the one with the greatest MAGEST * * @memberof OPS * @params {(number|Array&lt;number&gt;)} arguments * @return {(number|Array&lt;number&gt;)} */ 'magest': { enumerable: true, value: (() =&gt; { let code = 'magest' let base = 0 let desc = 'greatest magnitude' return Object.assign( function (...args) { let max = base if ([...arguments].every(Foft.ISARRAYLIKE) &amp;&amp; (arguments.length &gt; 1)) { let maxmagest = base let magesti = base for (let i = 0; i &lt; arguments.length; i++) { let cur = Foft.OPS['magest'](...arguments[i]) // console.log(cur) if (cur &gt; maxmagest) { maxmagest = cur magesti = i } } return arguments[magesti] } else if (Foft.ARECALCULABLES(...arguments)) { for (var i = 0; i &lt; arguments.length; i++) { let cur = Math.abs(arguments[i]) max = (cur &gt; max) ? cur : max } return max } else { return NaN } }, { code, base, desc } ) })(), configurable: false, writable: false }, /** * @name magesti - given some values, return the first INDEX of the one with the greatest MAGEST * * @memberof OPS * @params {(number|Array&lt;number&gt;)} * @return {number} */ 'magesti': { enumerable: true, value: (() =&gt; { let code = 'magesti' let base = 0 let desc = 'index of greatest magnitude' return Object.assign( function () { let magests = Array(arguments.length) for (let i = 0; i &lt; arguments.length; i++) { let a = arguments[i] magests[i] = (Foft.ISARRAYLIKE(a)) ? Foft.OPS['magest'](...a) : Foft.OPS['magest'](a) } let index = magests.findIndex((v) =&gt; { // console.log(v) return Foft.EQUAL( v, Foft.OPS['magest'](...magests) ) }) return index }, { code, base, desc } ) })(), configurable: false, writable: false } }), enumerable: true, configurable: false, writable: false }, /** * dimensional labeling * @memberof Foft * @static */ 'R': { value: ['x', 'y', 'z'], enumerable: true, configurable: false, writable: false }, /** * methods for inter-instance communication * @see TTHIS_TEMPLATE * @memberof Foft * @static */ 'FUNCKEYS': { value: [ 'normalizeT', 'antinormalizeT', 'i' ], enumerable: true, configurable: false, writable: false }, /** * members for inter-instance communication * @see TTHIS_TEMPLATE * @memberof Foft * @static */ 'MEMBERKEYS': { value: [ 'range', 'drange', 't0', 'segmentDivisor' ], enumerable: true, configurable: false, writable: false }, /** * DEFAULT_SEGMENT_DIVISOR By default, Foft instances divide into * this many segments * @type {Number} * @memberof Foft * @default 10 * @static */ 'DEFAULT_SEGMENT_DIVISOR': { value: 10, enumerable: true, configurable: false, writable: false }, /** * MAX_SAFE_DIVISOR the maximum safe to use divisor * @borrows Foft.CALC_PRECISION_WARN * @memberof Foft * @static */ 'MAX_SAFE_DIVISOR': { value: Foft.CALC_PRECISION_WARN(), enumerable: true, configurable: false, writable: false }, /** * DEFAULT_RANGE By default, Foft instances evaluate functions over this range * @type {Array.&lt;Number&gt;} * @default [-1,1] * @memberof Foft * @static */ 'DEFAULT_RANGE': { value: [-1, 1], enumerable: true, configurable: false, writable: false } }) export { Foft } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes Foft Classes Classes Foft × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes Foft — foft — Documentation Syntactic sugar for discontinuous (mathematical) functions. It Is A lot of syntactic sugar For investigating the results of known arithmetic expressions provided as functions in JavaScript over specified evaluation ranges, For investigating floating-point error tendencies in a JavaScript environment, and An ECMAScript module for browsers or nodejs. It Is not Fast, A comprehensive calculator, Immune to inaccuracies, A computer algebra system, An equation solver, or An expression parser. Usage: Foft exports a single class, Foft that can create an instance as well as provide some static utilities. Example: import {Foft} from 'foftjs'; m = new Foft({ terms: [t =&gt; 2*t], range: [0, 10], segmentDivisor: 10 // 10 }); [...m] // Array(11) [ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 ] // 10+1 Generally, a Foft instance can evaluate: Its terms: Function or Foft instances that should generally receive and return Numbers Arrays of Numbers, Nested Arrays of Numbers, or TypedArrays. Some of the properties of its terms(1). Development Guidelines Testing in nodejs Run npm test Documentation Run npm run-script docs × Search results Close "},"Foft.html":{"id":"Foft.html","title":"Class: Foft","body":" Documentation Classes Foft Class: Foft Foft Foft is a class that evaluates the properties of Function or Foft objects that generally receive and return objects of type Number Array of Number, Array of Array new Foft(params) create a Foft instance that evaluates its Function terms when given some parameter \"t\". accepts an argument params that may be a(n): function see params.terms for details object see params for details array of numbers see params.range for details Foft instance will return a copy of the instance Parameters: Name Type Description params Object | function | Array.&lt;Number&gt; | Foft Properties Name Type Argument Default Description range Number | Array.&lt;Number&gt; &lt;optional&gt; Range of two numerical values over which t is evaluated inclusively. If given a single number t0, range is [-t0,t0] segmentDivisor Number &lt;optional&gt; The number of segments to divide the range into when picking t values for evaluation. terms function | Array.&lt;function()&gt; | Array.&lt;Foft&gt; &lt;optional&gt; [] A function that accepts a parameter t and returns a result of some operation on t rangeoverride boolean &lt;optional&gt; false if true, will override any range provided and set range equal to [0, params.segmentDivisor] harmonize boolean &lt;optional&gt; false if true, will harmonize the domains of any Foft terms to that of the new parent instance @see range, @see segmentDivisor Source: foft.js, line 44 See: Foft.oft Throws: TypeError Examples // returns a Foft instance let MoT = new Foft() // returns a Foft instance that // describes an equation over the range [0,1] (inclusive) // split into 22 segments (23) total points let MoT = new Foft({ range: [0, 1], segmentDivisor: 22, terms: (t) =&gt; t*2; }); Foft also evaluates some of the properties of the Function or Foft objects in its terms Members &lt;static&gt; DEFAULT_RANGE :Array.&lt;Number&gt; DEFAULT_RANGE By default, Foft instances evaluate functions over this range Type: Array.&lt;Number&gt; Default Value: [-1,1] Source: foft.js, line 1677 &lt;static&gt; DEFAULT_SEGMENT_DIVISOR :Number DEFAULT_SEGMENT_DIVISOR By default, Foft instances divide into this many segments Type: Number Default Value: 10 Source: foft.js, line 1652 &lt;static&gt; FUNCKEYS methods for inter-instance communication Source: foft.js, line 1617 See: TTHIS_TEMPLATE &lt;static&gt; MATHTYPES valid types that Foft can do math on Source: foft.js, line 1273 See: Foft.MATHTYPEOF &lt;static&gt; MAX_SAFE_DIVISOR MAX_SAFE_DIVISOR the maximum safe to use divisor Source: foft.js, line 1664 &lt;static&gt; MEMBERKEYS members for inter-instance communication Source: foft.js, line 1633 See: TTHIS_TEMPLATE &lt;static&gt; OPDICT an array of valid op keys Source: foft.js, line 1294 See: Foft.OPS &lt;static&gt; OPS OPS an object containing operations, or ops, that perform mathematical functions corresponding to their keys Source: foft.js, line 1310 See: Foft.ISOP Foft.OPDICT Foft.OPPARSE Foft.ARENUMBERS &lt;static&gt; R dimensional labeling Source: foft.js, line 1605 dabsrange the absolute value of the delta between the first and final values of the evaluation range Source: foft.js, line 317 drange the delta between the the first and final values of the evaluation range Source: foft.js, line 308 dt get the delta for t between the first and final values of the evaluation range. May be innacurate when the range has more than two terms Source: foft.js, line 198 numSegments The number of actual segments the Foft divides the evaluation range into Source: foft.js, line 187 ofAlltT get a Generator that yields all Array=[t, this.oft(t)] for t in evaluation range in form [t, this.oft(t)] Source: foft.js, line 679 See: oft ofAlltTOp get a Generator that yields all this.oftOp(_t, _acc, _op) for _t in T, _acc, _op provided by user Source: foft.js, line 710 See: ofAlltTOp ofFirstt return the oft for the first t in the evaluation range Source: foft.js, line 530 See: t0 oft ofLastt return the oft for the final t in the evaluation range Source: foft.js, line 540 See: range oft opcode a Foft can have an opcode as defined in Foft.OPS. These codes represent mathematical operations between Numbers and other types. They are useful for performing said operations when the Function or Foft in the terms Array Source: foft.js, line 253 See: Foft.OPS terms opcode set opcode - set the opcode to one of the opcodes defined in Foft.OPS Source: foft.js, line 263 range set range - only accepts an arraylike of calculables Source: foft.js, line 207 range get the evaluation range is the minimum and maximum values for t Source: foft.js, line 220 segmentDivisor set segmentDivisor - set the segment divisor for the evaluation range where the range will be divided into (segmentDivisor+1) segments, if given an arraylike parameter, use the 0th value if given a calculable parameter, use it as-is Source: foft.js, line 160 segmentDivisor get segmentDivisor The number of segment divisors (number of t evaluation points -1) in this Foft Source: foft.js, line 178 T get a Generator yielding all values of t across instance evaluation range Source: foft.js, line 367 Example // get the default t values for which a Foft is // evaluated let MoT = new Foft({ range: [0, Math.PI*2], segmentDivisor: 22, terms: (t) =&gt; [sin(t), cos(t)]; }); let T = [...MoT.T()] t0 get the first value of t in the evaluation range T Source: foft.js, line 229 See: T terms the Function terms of this Foft object Source: foft.js, line 109 tt the last value of t in the evaluation range T Source: foft.js, line 238 See: T Methods &lt;static&gt; ANTINORMALIZETORANGE( [t] [, TT]) given a Number t, amd a ramge TT, return a normalized (to Foft.DEFAULT_RANGE) representation of the ratio between the two deltas A and B where A is the difference betewen t and TT[last] B is the difference between TT[last] and TT[first] If t falls out of bounds of range, the value is returned as -/+ Infinity, where: +Infinity corresponding to beyond the bound of TT[first], and -Infinity corresponding to beyond the bound of TT[last] Parameters: Name Type Argument Default Description t number &lt;optional&gt; 0 the t to evaluate TT Array.&lt;number&gt; &lt;optional&gt; DEFAULT_RANGE the range in which to test for TT Source: foft.js, line 1051 See: NORMALIZETORANGE Returns: Type number &lt;static&gt; ARECALCULABLES() ARECALCULABLES return true IFF one of these conditions are met The provided arguments are ALL of Number type, The sole provided argument is an Array whose members are ALL of Number type, Any provided argument is an Array whose members are A. ALL of Number type, or B. nested Arrays whose submembers are all number types or Array, and ALL other arguments are Number type or Array with ALL members of Number type, and All arguments of number type are neither NaN nor -/+Infinity Source: foft.js, line 929 See: ARENUMBERS Returns: Type boolean &lt;static&gt; ARENUMBERS() ARENUMBERS return true IFF one of these conditions are met The provided arguments are ALL of Number type, The sole provided argument is an Array whose members are ALL of Number type, Any provided argument is an Array whose members are A. ALL of Number type, or B. nested Arrays whose submembers are all number types or Arrays and ALL other arguments are Number type or Array with ALL members of Number type, Source: foft.js, line 900 See: ARECALCULABLES Returns: Type boolean &lt;static&gt; CALC_PRECISION_WARN() give precision warning in the form of an object that can be converted to a primitive. Floating point math has inherent imprecisions. This function is useful for quantifying them and identifying potentially problematic operations. It uses a few different tests to highlight sources of error, including: a*\\frac{1}{a} // Multiplicative Identity \\sum_{i=1}^{a} 1/a // Sum of Inverses Source: foft.js, line 783 Returns: the object with primitive values: {number} the maximum value for which no precision is lost {string} as brief message Type object &lt;static&gt; DIMENSIONS(x) return the size of the given x, where x can be a number or an arraylike or a nested arraylike Parameters: Name Type Description x number | Array the structure to get dimensions of Source: foft.js, line 1097 Returns: Type Array &lt;static&gt; EQUAL() determine whether the given number or Array-like arguments are satisfying the conditions: all of a single shared type, if numbers, of equal value, if arrays, composed of equal positional elements if other types, satisfying strict equality test When comparing values that are NaN or containing NaN in the same positions, the function will return false because NaN doesn't equal NaN Source: foft.js, line 1157 Returns: Type boolean &lt;static&gt; IINRANGE(t, TT, d) given a number t, a range TT and a divisor d, return the value of the corresponding i such that i is proportional to the location of t within the range i is proportional to d Parameters: Name Type Description t number t to find in TT TT Array.&lt;number&gt; range d type divisor Source: foft.js, line 1078 Returns: Type null | number &lt;static&gt; INRANGE(n [, m] [, mm]) determine whether a given number n falls within any of the follwoing inclusive ranges 0. [ Foft.DEFAULT_RANGE[0], Foft.DEFAULT_RANGE[1] ] [0, m], [0, m[0]], (when provided unit-length array) [m[0], m[m.length-1]] 4, [m, mm] Parameters: Name Type Argument Description n Number the number to test m Number | Array.&lt;Number&gt; &lt;optional&gt; the end of the range starting with 0, or the Array representing the range [m[0], m[last]] the begining of range ending in mm, or mm Number &lt;optional&gt; the optional end of the range Source: foft.js, line 958 Returns: Type boolean &lt;static&gt; ISARRAYLIKE(x) determine whether a given argument x is \"like\" an array for the purposees of Foft calculations and parsing, returning true IFF x satisfies one of the following conditions: 1 - It is an Array 2 - It is a TypedArray 3 - It provides a Symbol.iterator property The third condition allows for the parsing of various iterable objects, but it does not guarantee that such actions will produce calculable values. Parameters: Name Type Description x ? Source: foft.js, line 880 Returns: Type boolean &lt;static&gt; ISCALCULABLE() return true IFF all of the following conditions are met argument satisfies ISNUMBER (One Number argument) argument is not NaN argument is not +/-Infinity This function does more calls than just using isFinite, however, it is used in the Foft class because the class also deals with arrays and objects. Source: foft.js, line 864 See: ISNUMBER Returns: description Type boolean &lt;static&gt; ISNUMBER() return true IFF both of the following conditions are met there was ONE argument provided, and the sole provided argument was a Number Source: foft.js, line 847 Returns: Type boolean &lt;static&gt; ISOP(codeToParse) given a string codeToParse, return true when code is found in Foft.OPDICT Parameters: Name Type Description codeToParse string Source: foft.js, line 1246 See: Foft.OPDICT Returns: Type boolean &lt;static&gt; MATHTYPEOF( [a]) tell whether the given argument a is of one of the types that Foft can do math with and if so, which type Parameters: Name Type Argument Description a ? &lt;optional&gt; Source: foft.js, line 1196 Returns: Type Symbol | null &lt;static&gt; NORMALIZETORANGE( [t] [, TT] [, NN]) given a Number t, amd a ramge TT, return a normalized (to an optional range NN or Foft.DEFAULT_RANGE) representation of the ratio between the two deltas A and B where A is the difference betewen t and TT[first] B is the difference between TT[last] and TT[first] If t falls out of bounds of range, the value is returned as -/+ Infinity, where: -Infinity corresponding to beyond the bound of TT[first], and +Infinity corresponding to beyond the bound of TT[last] Parameters: Name Type Argument Default Description t number &lt;optional&gt; 0 the t to evaluate TT Array.&lt;number&gt; &lt;optional&gt; DEFAULT_RANGE the range in which to test for TT NN Array.&lt;number&gt; &lt;optional&gt; DEFAULT_RANGE the target normalization range * @return {number} Source: foft.js, line 1005 &lt;static&gt; OPPARSE(codeToParse) given a string codeToParse, return the corresponding operation function from Foft.OPS Parameters: Name Type Description codeToParse string Source: foft.js, line 1259 See: Foft.OPS Returns: Foft.OPS function corresponding to op Type function &lt;static&gt; TTHIS_TEMPLATE(t, foft) given a t and a Foft instance, produces an object with some keys for inter-instance communication corresponding to: 1 the result of evaluating certain methods of the calling instance for t @see FUNCKEYS 2 certain members of the calling instance @see MEMBERKEYS Parameters: Name Type Description t Number the t of the instance communicatiing foft Foft the instance doing communication Source: foft.js, line 1215 See: oft Returns: communication object, or array of communication keys Type object | Array.&lt;string&gt; addTerm(term [, harmonize]) add a term to the terms of this Foft instance Parameters: Name Type Argument Default Description term function | Foft A Function that takes a parameter (t) or Foft harmonize boolean &lt;optional&gt; false if true, and term is a Foft instance, this overwrites the range and segmentDivisor of term to make them reference the same-named parameters of this instance. Source: foft.js, line 123 Returns: true if length of terms grew Type boolean antinormalizeT(t) given a number t return a normalized representation of the ratio of a quantity n to the delta of the instance evaluation range such that the ratio of t to the delta of the evaluation range N satisfies 1.n = maximum normal - N This is the remaining range for the normalized value provided by normalizeT if t falls beyond the lower bound of the evaluation range, return +Infinity if t falls beyond the upper bound of the evaluation range, return -Infinity Parameters: Name Type Description t number Source: foft.js, line 430 See: normalizeT Returns: n Type number dSubrange( [n] [, nn]) given indices n &amp; nn returns the delta between sub values in the Foft instance's evaluation range, or: range[nn%range.length]-range[n%range.length], when given no parameters, it uses 0 and 1 Parameters: Name Type Argument Default Description n Number &lt;optional&gt; 0 the starting range index. nn Number &lt;optional&gt; n+1%this.range.length the end range index Source: foft.js, line 281 Throws: when given non-number parameter Type TypeError Returns: Type Number i(t) given a Number t within a the evaluation range of this instance (inclusive), return the value of the corresponding i such that i is proportional to the location of t within the range i is scaled to segmentDivisor If t falls out of bounds of the range, nothing is returned If the range has more than two elements, return an array of length range-1 Parameters: Name Type Description t Number Source: foft.js, line 449 See: IINRANGE segmentDivisor normalizeT Returns: [0, segmentDivisor] Type Number | null | Array.&lt;(number|null)&gt; isInRange(t) return true IFF a given t falls within the evaluation range of this instance Parameters: Name Type Description t number Source: foft.js, line 468 Returns: Type boolean mapT( [callback] [, thisArg]) apply the Array.map native function to the elements yielded by this[Symbol.iterator] with the given callback function and this argument * Parameters: Name Type Argument Description callback function &lt;optional&gt; callback to apply thisArg Object &lt;optional&gt; this argument Source: foft.js, line 725 See: get [Symbol.iterator] Returns: map result Type Array mapTOp( [callback] [, thisArg]) apply the Array.map native function to the elements of this.ofAllTOp() with the given callback function and this argument Parameters: Name Type Argument Description callback function &lt;optional&gt; callback to apply thisArg Object &lt;optional&gt; this argument Source: foft.js, line 739 See: Array.map ofAllTOp Returns: map result Type Array normalizeT( [t] [, doAnti]) given a Number t, return a normalized (to Foft.DEFAULT_RANGE) representation of the ratio between t and the delta of the evaluation range of this Foft If t falls out of bounds of range, the value is returned as -/+ Infinity If the evaluation range has more than two values, e.g. [0,1,2], then normalizeT checks in each subrange, e.g. [0,1], [1,2] and returns an Array of normalized values corresponding to each range Parameters: Name Type Argument Default Description t Number &lt;optional&gt; 0 doAnti boolean &lt;optional&gt; false Source: foft.js, line 398 See: NORMALIZETORANGE DEFAULT_RANGE Returns: Type Number | Array.&lt;Number&gt; oft( [t] [, filterNulls] [, maketthis]) evaluate all of the terms held by this Mathoft for the given t value. When evaluating a Function or Foft term, the function or Foft is called with a this object containing certain useful data regarding the calling instance's evaluation of t @see TTHIS_TEMPLATE When evaluating a Foft term, any t that falls outside that term's evaluation range will produce a null result. If the filterNulls parameter is true, then null values will be stripped from the returned result. Parameters: Name Type Argument Default Description t Number &lt;optional&gt; t0 filterNulls boolean &lt;optional&gt; false maketthis boolean &lt;optional&gt; true Source: foft.js, line 484 See: isInRange Returns: Type Number | Array.&lt;Number&gt; | Array.&lt;Array&gt; oftNormal( [tNormal]) Accepts a Number tNormal that falls within Foft.DEFAULT_RANGE, inclusive, and when provided 1 . A NaN value, return NaN 2. +Infinity, returns evaluation from end bound of range 3. -Infinity, returns evaluation from start bound of range 4. Any other number even outside of normal range, returns value of that t. Parameters: Name Type Argument Default Description tNormal Number &lt;optional&gt; [-1,1] Source: foft.js, line 559 See: ISCALCULABLE ofFirstt ofLastt DEFAULT_RANGE oft Returns: Type Number | Array.&lt;Number&gt; oftOp(t [, _op] [, _acc]) Calculate the value of performing an operation _op on the values returned by calculating this Foft instance's terms for some evaluation value t. When given a parameter _acc, the calculation of _op will use _acc as its starting value. This is intended to facilitate convenient manipulation of terms and results. Parameters: Name Type Argument Default Description t Number the t to evaluate _op string &lt;optional&gt; this.opcode an opcode to perform @see Foft.OPS _acc Number | Array.&lt;Number&gt; | Array.&lt;Array&gt; &lt;optional&gt; null an accumulator value to start with @see Foft.OPS -&gt; base Source: foft.js, line 593 See: oft Returns: Type Number | Array.&lt;Number&gt; | Array.&lt;Array&gt; subT( [n]) get a generator function that yields segmentDivisor+1 values of t spanning the range [this.range[n], this.range[n+1]], where if n or n+1 fall beyond the bounds of this.range.length, they are constrained to fit Parameters: Name Type Argument Default Description n Number &lt;optional&gt; 0 integer start index of range Source: foft.js, line 328 Returns: description Type type toString() toString Source: foft.js, line 750 Returns: Type string × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
