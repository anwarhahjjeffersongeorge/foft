<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"foft.js.html":{"id":"foft.js.html","title":"Source: foft.js","body":" Documentation Classes Foft Global \"...\" Source: foft.js 'use strict' /** * @class Foft is a class that evaluates the * properties of Function or Foft objects that * generally receive and return objects of type * - Number * - Array of Number, * - Array of Array * @example * // returns a Foft instance * let MoT = new Foft() * @example * // returns a Foft instance that * // describes an equation over the range [0,1] (inclusive) * // split into 22 segments (23) total points * let MoT = new Foft({ * range: [0, 1], * segmentDivisor: 22, * terms: (t) =&gt; t*2; * }); * Foft also evaluates some of the properties * of the Function or Foft objects in its terms * @see Foft.oft */ class Foft { /** * constructor - create a Foft instance that evaluates its Function terms * when given some parameter \"t\". * @param {(Object|Function|Array)} params * @param {(Number|Array.&lt;Number&gt;)} [params.range] Range of two numerical values over which t is evaluated inclusively. If given a single number t0, range is [-t0,t0] * @param {Number} [params.segmentDivisor] The number of segments to divide the range into when picking t values for evaluation. * @param {(Function|Array.&lt;Function&gt;|Array.&lt;Foft&gt;)} [params.terms=[]] A function that accepts a parameter t and returns a result of some operation on t * @param {boolean} [params.rangeoverride=false] if true, will override any range provided and set range equal to [0, params.segmentDivisor] * @param {boolean} [params.harmonize=false] if true, will harmonize the domains of any Foft terms to that of the new parent instance @see range, @see segmentDivisor * @throws TypeError */ constructor (params) { params = params || {} if ((typeof params === 'function') || (params instanceof Foft)) { let thefunc = params params = { terms: thefunc } } else if (Foft.ISARRAYLIKE(params)) { let thearray = params params = { range: thearray } } // define the division of the evaluation range const segmentDivisor = params.segmentDivisor || Foft.DEFAULT_SEGMENT_DIVISOR this.segmentDivisor = segmentDivisor let rangeoverride = (typeof params.rangeoverride === 'boolean') ? params.rangeoverride : false let harmonize = (typeof params.harmonize === 'boolean') ? params.harmonize : false // create an evaluation range let range = (rangeoverride) ? [0, this.segmentDivisor] : params.range || Foft.DEFAULT_RANGE range = Foft.ISCALCULABLE(range) ? [-range, range] : range if (!Foft.ISARRAYLIKE(range)) throw new TypeError('range should be array') // if(range.length!==2) throw new RangeError('range should have two elements') this.range = Array.from(range) // this Foft can use these terms // define terms this._terms = [] let terms = params.terms || [(t) =&gt; t] terms = (typeof terms === 'function') ? [terms] : terms if (!Foft.ISARRAYLIKE(terms) &amp;&amp; (typeof terms !== 'function') &amp;&amp; !(terms instanceof Foft)) { throw new TypeError('params.terms should be array, function or Foft instance') } for (let term of terms) { // const term = terms[termIndex]; // console.log(term);`` this.addTerm(term, harmonize) } // console.log(params.opcode) // debugger; this.opcode = params.opcode // return this.bind(this); // this['__call__']=(...args)=&gt;{ // console.log('__call__', this._range) // return this.oft.call(...args); // } } // // '__call__'(t, filterNulls){ // console.log('__call__', this.range) // return this.oft(t, filterNulls,false); // } /** * get terms - the Function terms of this Foft object * * @return {Array} */ get terms () { return this._terms } /** * addTerm - add a term to the terms of this Foft instance * * @param {(function|Foft)} term A Function that takes a parameter (t) or * Foft * @param {boolean} [harmonize=false] if true, and term is a Foft * instance, this overwrites the range and segmentDivisor of term to make them * reference the same-named parameters of this instance. * @returns {boolean} true if length of terms grew */ addTerm (term, harmonize) { let numterms = this.terms.length const push = (_term) =&gt; { this.terms.push(_term) this[numterms] = this.terms[numterms] } harmonize = (typeof harmonize === 'boolean') ? harmonize : false if (typeof term === 'function' &amp;&amp; !(term instanceof Foft)) { push(term) } else if (term instanceof Foft) { push(term) if (harmonize) { // term.range = this.range; // term.segmentDivisor = this.segmentDivisor; const keys = ['_range', '_segmentDivisor'] for (let key of keys) { Object.defineProperty(term, key, { get: () =&gt; this[key], // reference to parent set: (value) =&gt; Object.defineProperty(term, key, { value })// dareference from parent }) } } } return numterms === this.terms.length - 1 } /** * set segmentDivisor - set the segment divisor for the evaluation range where * - the range will be divided into (segmentDivisor+1) segments, * - if given an arraylike parameter, use the 0th value * - if given a calculable parameter, use it as-is * * * @param {number|arraylike&lt;number&gt;} segmentDivisor * @throws {TypeError} segmentDivisor should be calculable number */ set segmentDivisor (segmentDivisor) { segmentDivisor = Foft.ISARRAYLIKE(segmentDivisor) ? segmentDivisor[0] : segmentDivisor if (!Foft.ISCALCULABLE(segmentDivisor)) { // console.log('NaN segment Divisor') throw new TypeError('segmentDivisor should be calculable number, not: ' + segmentDivisor) } else { this._segmentDivisor = [segmentDivisor] } } /** * get segmentDivisor The number of segment divisors * (number of t evaluation points -1) * in this Foft * * @return {Number} */ get segmentDivisor () { return this._segmentDivisor[0] } /** * get numSegments - The number of actual segments the Foft divides the evaluation range into * * @return {Number} */ get numSegments () { return this.segmentDivisor + 1 } /** * get dt - get the delta for t between the first and final values of the * evaluation range. May be innacurate when the range has more than two * terms * * @return {number} */ get dt () { return this.drange / this.segmentDivisor } /** * set range - only accepts an arraylike of calculables * * @param {Array&lt;number&gt;} range */ set range (range) { if (!(Foft.ISARRAYLIKE(range) &amp;&amp; Foft.ARECALCULABLES(range))) throw new TypeError('range values should be Array of calculable numbers') this._range = Array(range.length) for (let rangeIndex in range) { this._range[rangeIndex] = range[rangeIndex] } } /** * get range - the evaluation range is the minimum and maximum values for t * * @return {Array.&lt;Number&gt;} */ get range () { return this._range } /** * get t0 - the first value of t in the evaluation range T * @see T * @return {Number} */ get t0 () { return this.range[0] } /** * get tt - the last value of t in the evaluation range T * @see T * @return {Number} */ get tt () { return this.range[this.range.length - 1] } /** * get opcode - a Foft can have an opcode as defined in * Foft.OPS. These codes represent mathematical operations * between Numbers and other types. They are useful for performing * said operations when the Function or Foft in the terms * Array * * @see Foft.OPS * @see terms * @return {string} @see Foft.OPS */ get opcode () { return this._opcode } /** * set opcode - set the opcode to one of the opcodes * defined in Foft.OPS * * @param {string} [opcode=null] @see Foft.OPS */ set opcode (opcode) { this._opcode = (Foft.ISOP(opcode)) ? opcode : null } /** * get dSubrange - given indices n &amp; nn * returns the delta between sub values in the Foft instance's * evaluation range, or: range[nn%range.length]-range[n%range.length], * * when given no parameters, it uses 0 and 1 * * @param {Number} [n=0] the starting range index. * @param {Number} [nn=n+1%this.range.length] the end range index * @return {Number} * @throws {TypeError} when given non-number parameter */ dSubrange (n, nn) { n = Foft.ISNUMBER(n) ? n : 0 if (nn &amp;&amp; !Foft.ISNUMBER(nn)) { throw new TypeError(`Foft.dSubRange only accepts Numbers, given ${[...arguments]}`) } n = n % this.range.length if (!Number.isInteger(n)) { throw new RangeError(`Foft.dSubRange only accepts Integers, given ${[...arguments]}`) } // for this conditional, we use the explicit ISNUMBER to avoid logical // error for zero case: if(0) is falsy nn = Foft.ISNUMBER(nn) ? nn % this.range.length : (n + 1) % this.range.length if (!Number.isInteger(nn)) { throw new RangeError(`Foft.dSubRange only accepts Integers, given ${[...arguments]}`) } return this.range[nn] - this.range[n] } /** * get drange - the delta between the the first and final values of the evaluation range * * @return {Number} */ get drange () { return this.range[this.range.length - 1] - this.range[0] } /** * get dabsrange - the absolute value of the delta * between the first and final values of the evaluation range * * @return {Number} */ get dabsrange () { return Math.abs(this.drange) } /** * subT - get a generator function that yields segmentDivisor+1 values of t spanning the range [this.range[n], this.range[n+1]], where if n or n+1 fall beyond the bounds of this.range.length, they are constrained to fit * * * * @param {Number} [n=0] integer start index of range * * @return {type} description */ subT (n, omitLast) { omitLast = (typeof omitLast === 'boolean') ? omitLast : false let defaultN = 0 n = Foft.ISNUMBER(n) ? n % this.range.length : defaultN let a = this.range[n] let b = this.range[(n + 1) % this.range.length] let tsubmax = (omitLast) ? this.segmentDivisor - 1 : this.segmentDivisor let dt = (b - a) / this.segmentDivisor /** * @yields {Number} */ return function * () { for (let tsubindex = 0; tsubindex &lt;= tsubmax; tsubindex++) { yield a + tsubindex * dt } } } /** * get T - get a Generator yielding all values of t across instance evaluation range * @example * // get the default t values for which a Foft is * // evaluated * let MoT = new Foft({ * range: [0, Math.PI*2], * segmentDivisor: 22, * terms: (t) =&gt; [sin(t), cos(t)]; * }); * let T = [...MoT.T()] * @return {Generator&lt;Number&gt;} */ get T () { let rangelimit = this.range.length - 2 /** * @yields {Number} */ return function * () { for (let rangeIndex = 0; rangeIndex &lt;= rangelimit; rangeIndex++) { yield * (rangeIndex === rangelimit) ? this.subT(rangeIndex)() : this.subT(rangeIndex, true)() // chop last to eliminate double values } } } /** * normalizeT - given a Number t, return a normalized (to Foft.DEFAULT_RANGE) * representation of the ratio between t and the delta of the evaluation * range of this Foft * * If t falls out of bounds of range, the value is returned as -/+ Infinity * * If the evaluation range has more than two values, e.g. [0,1,2], * then normalizeT checks in each subrange, e.g. [0,1], [1,2] * and returns an Array of normalized values corresponding to each range * * @see NORMALIZETORANGE * @see DEFAULT_RANGE * @param {Number} [t=0] * @param {boolean} [doAnti=false] * @return {Number|Array&lt;Number&gt;} */ normalizeT (t, doAnti) { doAnti = (typeof doAnti === 'boolean') ? doAnti : false let func = (doAnti) ? Foft.ANTINORMALIZETORANGE : Foft.NORMALIZETORANGE let arr = Array(this.range.length - 1) for (let r = 0; r &lt; arr.length; r++) { arr[r] = func(t, [ this.range[r], this.range[r + 1] ]) } return (arr.length === 1) ? arr[0] : arr } /** * antinormalizeT - given a number t return a normalized representation of the ratio of a quantity n to the delta of the instance evaluation range such that the ratio of t to the delta of the evaluation range N satisfies * 1.n = maximum normal - N * * This is the remaining range for the normalized value provided by normalizeT * * if t falls beyond the lower bound of the evaluation range, return +Infinity * if t falls beyond the upper bound of the evaluation range, return -Infinity * * @see normalizeT * @param {number} t * @return {number} n */ antinormalizeT (t) { return this.normalizeT(t, true) } /** * i - given a Number t within a the evaluation range of this instance * (inclusive), return the value of the corresponding i such that * 1. i is proportional to the location of t within the range * 2. i is scaled to segmentDivisor * * If t falls out of bounds of the range, nothing is returned * * If the range has more than two elements, return an array of length range-1 * @see IINRANGE * @see segmentDivisor * @see normalizeT * @param {Number} t * @return {Number|null|Array&lt;number|null&gt;} [0, segmentDivisor] */ i (t) { let arr = Array(this.range.length - 1) for (let r = 0; r &lt; arr.length; r++) { arr[r] = Foft.IINRANGE(t, [ this.range[r], this.range[r + 1] ], this.segmentDivisor) } return (arr.length === 1) ? arr[0] : arr } /** * isInRange - return true IFF a given t falls within the evaluation range of this instance * * @param {number} t * @return {boolean} */ isInRange (t) { return Foft.INRANGE(t, this.range) } /** * oft - evaluate all of the terms held by this Mathoft for the * given t value. * * When evaluating a Function or Foft term, the function or Foft is called with a this object containing certain useful data regarding the calling instance's evaluation of t @see TTHIS_TEMPLATE * * When evaluating a Foft term, any t that falls outside that term's evaluation range will produce a null result. If the filterNulls parameter is true, then null values will be stripped from the returned result. * @see isInRange * @param {Number} [t=t0] * @param {boolean} [filterNulls=false] * @param {boolean} [maketthis=true] * @return {(Number|Array.&lt;Number&gt;|Array&lt;Array&gt;)} */ oft (t, filterNulls, maketthis) { // console.log(this) t = Foft.ISCALCULABLE(t) ? t : this.t0 filterNulls = (typeof filterNulls === 'boolean') ? filterNulls : false maketthis = (typeof maketthis === 'boolean') ? maketthis : true // debugger; let tthis = (maketthis) ? Foft.TTHIS_TEMPLATE(t, this) : (typeof this.tthis === 'object') ? this.tthis : null let result = [] for (let i in this.terms) { let _term = this.terms[i] if ( typeof _term === 'function') { result[i] = _term.call(tthis, t) } else if (_term instanceof Foft) { // console.log(_term); let subres = _term.isInRange(t) ? _term.oft.call(Object.assign(_term, { tthis }), t, null, false) : null result[i] = subres // OVERRIDE? } } result = (filterNulls) ? result.filter((v) =&gt; v) : result return (result.length === 1) ? result[0] : result } /** * get ofFirstt - return the oft for the first t in the evaluation range * * @see t0 * @see oft * @return {(Number|Array.&lt;Number&gt;|Array.&lt;Array&gt;)} */ get ofFirstt () { return this.oft(this.t0) } /** * get ofLastt - return the oft for the final t in the evaluation range * * @see range * @see oft * @return {(Number|Array.&lt;Number&gt;|Array.&lt;Array&gt;)} */ get ofLastt () { return this.oft(this.tt) } /** * oftNormal - Accepts a Number tNormal that falls within Foft.DEFAULT_RANGE, inclusive, and when provided * 1 . A NaN value, return NaN * 2. +Infinity, returns evaluation from end bound of range * 3. -Infinity, returns evaluation from start bound of range * 4. Any other number even outside of normal range, returns value of that t. * * @see ISCALCULABLE * @see ofFirstt * @see ofLastt * @see DEFAULT_RANGE * @see oft * @param {Number} [tNormal=[-1,1]] * @return {(Number|Array.&lt;Number&gt;)} */ oftNormal (tNormal) { let dNormal = Foft.DEFAULT_RANGE[1] - Foft.DEFAULT_RANGE[0] let midNormal = Foft.DEFAULT_RANGE[0] + dNormal / 2 tNormal = Foft.ISNUMBER(tNormal) ? tNormal : midNormal let t; let midt = (this.tt - this.t0) / 2 + this.t0 if (Foft.ISCALCULABLE(tNormal)) { t = midt + (tNormal - midNormal) * this.drange / 2 } // debugger; return (t !== undefined) ? this.oft(t) : (Number.isNaN(tNormal)) ? NaN : tNormal === -Infinity ? this.ofFirstt : this.ofLastt } /** * oftOp - Calculate the value of performing an operation _op on the * values returned by calculating this Foft instance's terms for * some evaluation value t. When given a parameter _acc, the calculation of _op will use _acc as its starting value. * * This is intended to facilitate convenient manipulation of terms and results. * * @see oft * * @param {Number} t the t to evaluate * @param {string} [_op=this.opcode] an opcode to perform @see Foft.OPS * @param {(Number|Array.&lt;Number&gt;|Array.&lt;Array&gt;)} [_acc=null] an accumulator value to start with @see Foft.OPS -&gt; base * @return {(Number|Array.&lt;Number&gt;|Array.&lt;Array&gt;)} */ oftOp (_t, _op, _acc) { _op = (_op in Foft.OPS) ? _op : this.opcode const op = Foft.OPS[_op] // debugger; _acc = ((_acc || Number.isNaN(_acc))) ? (Foft.ARENUMBERS(_acc)) ? _acc : NaN : null // op.base // debugger; const transform = (acc, val) =&gt; { let transformRes // console.log(acc,val); switch (Foft.MATHTYPEOF(val)) { case Foft.MATHTYPES.numberlike: if (Foft.ISARRAYLIKE(acc)) { throw new TypeError('Can\\'t apply an arraylike accumulator to a scalar.') } else if (Foft.ISNUMBER(acc)) { transformRes = op(acc, val) } break case Foft.MATHTYPES.arraylike: let isNested = Foft.ISARRAYLIKE(val[0]) if (Foft.ISARRAYLIKE(acc)) { if (acc.length !== val.length) { let areMismatched = (isNested) ? acc.length !== val[0].length : true if (areMismatched) { throw new TypeError('Can\\'t apply an op to arraylike values of dissimilar lengths.') } } if (isNested) { return val.reduce(transform, acc) } else { for (let i = 0; i &lt; val.length; i++) { val[i] = transform(acc[i], val[i]) // overwrite in place } } } else if (Foft.ISNUMBER(acc)) { for (let i = 0; i &lt; val.length; i++) { val[i] = transform(acc, val[i]) // overwrite in place } } transformRes = val break } return transformRes } let _oft = this.oft(_t) // if (!_op) { return op(_oft) } // console.log(_oft) // console.log(_acc); let res switch (this.terms.length) { case 1: res = (_acc || Number.isNaN(_acc)) ? transform(_acc, _oft) : _oft break default: res = (_acc || Number.isNaN(_acc)) ? Foft.ISARRAYLIKE(_acc) ? transform(_acc, _oft) : _oft.reduce(transform, _acc) : _oft.reduce(transform) break } return res } /** * get ofAlltT - get a Generator that yields * all Array=[t, this.oft(t)] for t in evaluation range * in form [t, this.oft(t)] * * @see oft * @return {Generator} */ get ofAlltT () { return function * () { for (let t of [...this.T()]) { yield [ t, this.oft(t) ] } } } /** * get - Symbol.iterator get a Generator that yields * all this.oft(t) for t in evaluation range * @see oft * @return {Generator} Generator function yielding this.oft(t) */ get [Symbol.iterator] () { return function * () { yield * [...this.T()].map((t, i) =&gt; this.oft(t)) } } /** * get ofAlltTOp - get a Generator that yields all * this.oftOp(_t, _acc, _op) for _t in T, * _acc, _op provided by user * * @see ofAlltTOp * @return {Generator} description */ get ofAlltTOp () { return function * (_acc, _op) { yield * [...this.T()].map((_t) =&gt; this.oftOp(_t, _op, _acc)) } } /** * map - apply the Array.map native function to the elements yielded by * this[Symbol.iterator] with the given callback function and this argument * * * @see get [Symbol.iterator] * @param {Function} [callback] callback to apply * @param {Object} [thisArg] this argument * @return {Array} map result */ mapT (callback, thisArg) { if (!(callback instanceof Function)) throw new TypeError('map needs Function callback') return [...this].map(callback, thisArg) } /** * mapTOp - apply the Array.map native function to the elements of * this.ofAllTOp() with the given callback function and this argument * @see Array.map * @see ofAllTOp * @param {Function} [callback] callback to apply * @param {Object} [thisArg] this argument * @return {Array} map result */ mapTOp (callback, thisArg) { if (!(callback instanceof Function)) throw new TypeError('map needs Function callback') return [...this.ofAlltTOp()].map(callback, thisArg) } /** * toString * * @override * @return {string} */ toString () { let res = 'Foft\\n' res += `range:\\n\\t[${this.range}]\\n` res += `segments:\\n\\t[${this.numSegments}]\\n` res += `terms:\\n` for (var i = 0; i &lt; this.terms.length; i++) { res += `\\t[${i}]: ${this.terms[i]}\\n` } res += `opcode:\\n\\t${this.opcode}` return res } /** * get Symbol.toStringTag * * @override * @return {string} */ get [Symbol.toStringTag] () { return 'Foft Function' } /** * @static CALC_PRECISION_WARN - give precision warning in the form of an object that can be converted to a primitive. * * Floating point math has inherent imprecisions. This function is useful for quantifying them and identifying potentially problematic operations. It uses a few different tests to highlight sources of error, including: * 1. a*\\frac{1}{a} // Multiplicative Identity * 2. \\sum_{i=1}^{a} 1/a // Sum of Inverses * @return {object} the object with primitive values: * {number} the maximum value for which no precision is lost * {string} as brief message */ static CALC_PRECISION_WARN (maxtestnum) { let res let getmsg = (e) =&gt; `Maximum safe unit divisor: ${e}` let tests = [ (a) =&gt; ((1 / a) * a === 1), // multiplicative identity (a) =&gt; Array(a).fill(1 / a).reduce((acc, val) =&gt; acc + val, 0) // sum of inverses ] // only do so many tests let testnum = 0 const maxtest = Foft.ISCALCULABLE(maxtestnum) ? maxtestnum : 144 // tests[0] let lastgoodmultidendivisor, msg // tests[1] let roundinaccura = [] // all divisors for which rounding error causes failure let rounddeltas = [] // the difference between erroneous rounding and 1 let roundexcesses = [] // divisors for which rounding error causes excess failure let rounddeficits = [] // divisors for which rounding error causes deficiency failure while (testnum &lt; maxtest) { // tests[0] if (!tests[0](++testnum)) { lastgoodmultidendivisor = testnum - 1 msg = getmsg(lastgoodmultidendivisor) } // tests[1] const test1result = tests[1](testnum) // testnum has been incremented already if (test1result !== 1) { roundinaccura.push(testnum) rounddeltas.push(test1result - 1) if (test1result &lt; 1) rounddeficits.push(testnum) if (test1result &gt; 1) roundexcesses.push(testnum) } }; res = { [Symbol.toPrimitive]: (hint) =&gt; { if (hint === 'number') return lastgoodmultidendivisor return msg }, inaccurateDivisors: { all: roundinaccura, errors: rounddeltas, excessive: roundexcesses, deficient: rounddeficits }, [Symbol.iterator]: function * () { yield * roundinaccura } } return res } /** * @static ISNUMBER - return true IFF both of the following conditions are met * 1. there was ONE argument provided, and * 2. the sole provided argument was a Number * * * @return {boolean} */ static ISNUMBER () { return (arguments.length === 1) &amp;&amp; (typeof arguments[0] === 'number') } /** * @static ISCALCULABLE - return true IFF all of the following conditions are met * 1. argument satisfies ISNUMBER (One Number argument) * 2. argument is not NaN * 3. argument is not +/-Infinity * * This function does more calls than just using isFinite, however, it is used in the Foft class because the class also deals with arrays and objects. * * @see ISNUMBER * * @return {boolean} description */ static ISCALCULABLE () { return (arguments.length === 1) &amp;&amp; Number.isFinite(arguments[0]) } /** * @static ISARRAYLIKE - determine whether a given argument x is \"like\" an array for the purposees of Foft calculations and parsing, returning true IFF x satisfies one of the following conditions: * 1 - It is an Array * 2 - It is a TypedArray * 3 - It provides a Symbol.iterator property * * The third condition allows for the parsing of various iterable objects, but it does not guarantee that such actions will produce calculable values. * * @param {?} x * @return {boolean} */ static ISARRAYLIKE (x) { return x &amp;&amp; (Object.getOwnPropertySymbols(x).includes(Symbol.iterator) || Array.isArray(x) || ArrayBuffer.isView(x)) } /** * @static ARENUMBERS return true IFF one of these conditions are met * 1. The provided arguments are ALL of Number type, * 2. The sole provided argument is an Array whose members are ALL of Number type, * 3. Any provided argument is an Array whose members are * A. ALL of Number type, or * B. nested Arrays whose submembers are all number types or Arrays * and ALL other arguments are Number type or Array with ALL members of Number type, * * @see ARECALCULABLES * * @params {} [arguments] figure out whether the arguments are numbers or * an Array thereof * @return {boolean} */ static ARENUMBERS () { if (arguments.length === 0) { return false } else { return [...arguments].every(v =&gt; { return Foft.ISARRAYLIKE(v) ? Foft.ARENUMBERS(...v) : Foft.ISNUMBER(v) }) } }; /** * @static ARECALCULABLES return true IFF one of these conditions are met * 1. The provided arguments are ALL of Number type, * 2. The sole provided argument is an Array whose members are ALL of Number type, * 3. Any provided argument is an Array whose members are * A. ALL of Number type, or * B. nested Arrays whose submembers are all number types or Array, * and ALL other arguments are Number type or Array with ALL members of Number type, and * 4. All arguments of number type are neither NaN nor -/+Infinity * * @see ARENUMBERS * * @params {} [arguments] figure out whether the arguments are numbers or * an Array thereof * @return {boolean} */ static ARECALCULABLES () { if (arguments.length === 0) { return false } else { return [...arguments].every(v =&gt; { return Foft.ISARRAYLIKE(v) ? Foft.ARECALCULABLES(...v) : Foft.ISCALCULABLE(v) }) } }; /** * @static INRANGE - determine whether a given number n falls * within any of the follwoing inclusive ranges * 0. [ Foft.DEFAULT_RANGE[0], Foft.DEFAULT_RANGE[1] ] * 1. [0, m], * 2. [0, m[0]], (when provided unit-length array) * 3. [m[0], m[m.length-1]] * 4, [m, mm] * * @param {Number} n the number to test * @param {(Number|Array&lt;Number&gt;)} [m] the end of the range starting with 0, or * the Array representing the range [m[0], m[last]] * the begining of range ending in mm, or * @param {Number} [mm] the optional end of the range * @return {boolean} */ static INRANGE (n, m, mm) { let test = (a, b, c) =&gt; { // console.log(a,b,c) return (a &gt; b) ? a &lt;= c : (a &lt; b) ? a &gt;= c : true // a === b } if (!(Foft.ARENUMBERS(...arguments) &amp;&amp; Foft.ISNUMBER(n))) { return false } else { if (arguments.length === 1) { return Foft.INRANGE(n, Foft.DEFAULT_RANGE) } else if (Foft.ISARRAYLIKE(m)) { // console.log(n,m) return (m.length === 1) ? test(n, 0, m[0]) : test(n, m[0], m[m.length - 1]) } else if (Foft.ISNUMBER(m)) { if (!Foft.ISNUMBER(mm)) { return test(n, 0, m) } else if (Foft.ISNUMBER(mm)) { return test(n, m, mm) } } } } /** * @static NORMALIZETORANGE - given a Number t, amd a ramge TT, return a normalized (to an optional range NN or Foft.DEFAULT_RANGE) * representation of the ratio between the two deltas A and B where * 1. A is the difference betewen t and TT[first] * 2. B is the difference between TT[last] and TT[first] * * * If t falls out of bounds of range, the value is returned as -/+ Infinity, * where: * 1. -Infinity corresponding to beyond the bound of TT[first], and * 2. +Infinity corresponding to beyond the bound of TT[last] * * * @param {number} [t=0] the t to evaluate * @param {Array&lt;number&gt;} [TT=DEFAULT_RANGE] the range in which to test for TT * @param {Array&lt;number&gt;} [NN=DEFAULT_RANGE] the target normalization range * @return {number} */ static NORMALIZETORANGE (t, TT, NN) { if (!Foft.ISNUMBER(t)) { t = 0 } if (!Foft.ARENUMBERS(NN)) { NN = Foft.DEFAULT_RANGE } if (!Foft.ARENUMBERS(TT)) { TT = Foft.DEFAULT_RANGE } let [normA, normB] = NN let minNorm = (normA &lt; normB) ? normA : normB // let maxNorm = (normB &gt; normA) // ? normB // : normA let res = (t - TT[0]) / (TT[1] - TT[0]) // [0-1] res = normA + (normB - normA) * res // [normA, normB] if (!Foft.INRANGE(res, normA, normB)) { res = (res &lt; minNorm) ? -Infinity : Infinity } return res } /** * @static ANTINORMALIZETORANGE - given a Number t, amd a ramge TT, return a normalized (to Foft.DEFAULT_RANGE) * representation of the ratio between the two deltas A and B where * 1. A is the difference betewen t and TT[last] * 2. B is the difference between TT[last] and TT[first] * * If t falls out of bounds of range, the value is returned as -/+ Infinity, * where: * 1. +Infinity corresponding to beyond the bound of TT[first], and * 2. -Infinity corresponding to beyond the bound of TT[last] * * @see NORMALIZETORANGE * @param {number} [t=0] the t to evaluate * @param {Array&lt;number&gt;} [TT=DEFAULT_RANGE] the range in which to test for TT * @return {number} */ static ANTINORMALIZETORANGE (t, TT, NN) { if (!Foft.ISNUMBER(t)) { t = 0 } if (!Foft.ARENUMBERS(TT)) { TT = Foft.DEFAULT_RANGE } if (!Foft.ARENUMBERS(NN)) { NN = Foft.DEFAULT_RANGE } let res = Foft.NORMALIZETORANGE(t, TT, NN) return (Math.abs(res) === Infinity) ? -res : NN[NN.length - 1] - res } /** * @static IINRANGE - given a number t, a range TT and a divisor d, return the value of the corresponding i such that * 1. i is proportional to the location of t within the range * 2. i is proportional to d * * @param {number} t t to find in TT * @param {Array&lt;number&gt;} TT range * @param {type} d divisor * @return {null|number} */ static IINRANGE (t, TT, d) { d = (Foft.ISNUMBER(d)) ? Math.floor(d) : Math.floor(Foft.DEFAULT_SEGMENT_DIVISOR) let res = Foft.NORMALIZETORANGE(t, TT, [0, 1]) return (res === Infinity) ? null : (res === -Infinity) ? null : Math.floor(res * d) } /** * @static DIMENSIONS - return the size of the given x, where x can be a number or an arraylike or a nested arraylike * * @param {(number|Array)} x the structure to get dimensions of * @return {Array} */ static DIMENSIONS (x) { let dim = Promise.resolve([]) if (Foft.ISNUMBER(x)) { return dim.then(dimarr =&gt; dimarr.concat(0)) } else if (Foft.ISARRAYLIKE(x)) { if (x.length === 0) { return dim.then(dimarr =&gt; dimarr.concat(0)) } else { let subarrayIndices = [] let isNotSubarrayTest = (acc, v, i) =&gt; { if (!Foft.ISARRAYLIKE(v)) { return acc &amp;&amp; true } else { subarrayIndices.push(i) return acc &amp;&amp; false } } if (x.reduce(isNotSubarrayTest, true)) { return dim.then(dimarr =&gt; dimarr.concat(x.length)) } else { return dim.then(dimarr =&gt; { return Promise.all(subarrayIndices.map((v) =&gt; { let xSubArr = x[v] // console.log(xSubArr) return Foft.DIMENSIONS(xSubArr) })).then(subdims =&gt; { // console.log(subdims, x.length) let flatsubdims = Foft.OPS['...'](subdims) // console.log(flatsubdims, x.length) let mag if (Foft.EQUAL(flatsubdims.length, subdims.length, x.length)) { mag = Foft.OPS.magest(...flatsubdims) } else { mag = Foft.OPS.magest(...subdims) } // mag = (Number.isNaN(mag) || mag === 0) // ? [] // : mag return dimarr.concat(x.length, mag) }) }) } } } return dim } /** * @static EQUAL - determine whether the given number or Array-like arguments are satisfying the conditions: * 1) all of a single shared type, * 2) if numbers, of equal value, * 3) if arrays, composed of equal positional elements * 4) if other types, satisfying strict equality test * * When comparing values that are NaN or containing NaN in the same positions, the function will return false because NaN doesn't equal NaN * * @params {?} [arguments] * @return {boolean} */ static EQUAL () { if (arguments.length === 0) { return false } if (arguments.length === 1) { return !Number.isNaN(arguments[0]) } const a0 = arguments[0] const a0type = Foft.MATHTYPEOF(a0) let res = true // const dim = Foft.DIMENSIONS(arguments[0]); for (let i = 1; i &lt; arguments.length; i++) { let a = arguments[i] if (Foft.MATHTYPEOF(a) !== a0type) return false switch (a0type) { case Foft.MATHTYPES.arraylike: if (a.length !== a0.length) return false for (let ai = 0; ai &lt; a0.length; ai++) { if (!Foft.EQUAL(a0[ai], a[ai])) return false } break case Foft.MATHTYPES.numberlike: res = res &amp;&amp; (a === a0) break default: // console.log(a) res = res &amp;&amp; (a === a0) } } return res } /** * @static MATHTYPEOF - tell whether the given argument a is of one of the types that Foft can do math with and if so, which type * * @param {?} [a] * @return {(Symbol|null)} */ static MATHTYPEOF (a) { return Foft.ISARRAYLIKE(a) ? Foft.MATHTYPES.arraylike : Foft.ISNUMBER(a) ? Foft.MATHTYPES.numberlike : null } /** * @static TTHIS_TEMPLATE - given a t and a Foft instance, produces an object with some keys for inter-instance communication corresponding to: * 1 the result of evaluating certain methods of the calling instance for t @see FUNCKEYS * 2 certain members of the calling instance @see MEMBERKEYS * * @see oft * @param {Number} t the t of the instance communicatiing * @param {Foft} foft the instance doing communication * @return {object|Array&lt;string&gt;} communication object, or array of communication keys */ static TTHIS_TEMPLATE (t, foft) { let o = (Foft.ISCALCULABLE(t)) ? { t } : { } let populateFunc = (foft instanceof Foft) &amp;&amp; (Foft.ISCALCULABLE(t)) ? (key) =&gt; { o[key] = foft[key](t) } : () =&gt; null let populateMemb = (foft instanceof Foft) ? (key) =&gt; { o[key] = foft[key] } : () =&gt; null Foft.FUNCKEYS.map(fkey =&gt; populateFunc(fkey)) Foft.MEMBERKEYS.map(mkey =&gt; populateMemb(mkey)) if (Object.keys(o).length === 0) { return Foft.FUNCKEYS.concat(Foft.MEMBERKEYS) } else { return o } }; /** * @static ISOP - given a string codeToParse, return true when code is found * in Foft.OPDICT * @see Foft.OPDICT * @param {string} codeToParse * @return {boolean} */ static ISOP (codeToParse) { return Foft.OPDICT.includes(codeToParse) } /** * @static OPPARSE - given a string codeToParse, return * the corresponding operation function from Foft.OPS * * @see Foft.OPS * @param {string} codeToParse * @return {function} Foft.OPS function corresponding to op */ static OPPARSE (codeToParse) { return (Foft.ISOP(codeToParse)) ? Foft.OPS[codeToParse] : Foft.OPS[null] } } Object.defineProperties(Foft, { /** * @static MATHTYPES - valid types that Foft can do math on * @see Foft.MATHTYPEOF * @memberof Foft */ 'MATHTYPES': { value: (() =&gt; { let o = {}; [ 'arraylike', 'numberlike' ].map(function (e) { this[e] = Symbol(e) this[this[e]] = e }, o) return o })(), enumerable: true, configurable: false, writable: false }, /** * @static OPDICT - an array of valid op keys * @see Foft.OPS * @memberof Foft */ 'OPDICT': { value: [null, '+', '-', '*', '/', '**', '...', 'magest', 'magesti'], enumerable: true, configurable: false, writable: false }, /** * @static OPS - an object containing operations, or ops, that * perform mathematical functions corresponding to their keys * @hamespace OPS * @see Foft.ISOP * @see Foft.OPDICT * @see Foft.OPPARSE * @see Foft.ARENUMBERS * @memberof Foft */ 'OPS': { value: Object.defineProperties({}, { 'opfunc': { value: (code, f) =&gt; { if (typeof code !== 'string') { throw new TypeError('Foft.OPS.opfunc takes one string') } else if (!Foft.OPDICT.includes(code)) { throw new RangeError('Foft.OPS.opfunc takes one string in Foft.OPDICT') } return (args) =&gt; [...args].reduce((acc, c, i) =&gt; f(acc, c)) }, writable: false, configurable: false, enumerable: false }, 'resfunc': { value: (code, f, base, args) =&gt; { if (!Foft.ISCALCULABLE(base)) { throw new TypeError('Foft.OPS.resfunc requires a calculable base parameter') } if (!Foft.ISARRAYLIKE(args)) { throw new TypeError('Foft.OPS.resfunc requires an iterable, Array or ArrayBuffer view args parameter') } if (Foft.ARENUMBERS(...args)) { return Foft.OPS.opfunc(code, f)(args) } let nullsReplaced = [...args].map(v =&gt; (v === null) ? base : v) if (Foft.ARENUMBERS(nullsReplaced)) { return Foft.OPS.opfunc(code, f)(nullsReplaced) } return NaN }, writable: false, configurable: false, enumerable: false }, [null]: { enumerable: true, value: (() =&gt; { let code = null let base = null let desc = 'null op' return Object.assign( function (...args) { return args }, { code, base, desc } ) })(), configurable: false, writable: false }, '+': { enumerable: true, value: (() =&gt; { let base = 0 let code = '+' let desc = 'summation' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a + b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, '-': { enumerable: true, value: (() =&gt; { let base = 0 let code = '-' let desc = 'subtraction' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a - b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, '*': { enumerable: true, value: (() =&gt; { let base = 1 let code = '*' let desc = 'multiplication' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a * b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, '/': { enumerable: true, value: (() =&gt; { let base = 1 let code = '/' let desc = 'division' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a / b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, '**': { enumerable: true, value: (() =&gt; { let base = 1 let code = '**' let desc = 'exponentiation' return Object.assign( function () { return Foft.OPS.resfunc(code, (a, b) =&gt; a ** b, base, arguments) }, { code, base, desc } ) })(), configurable: false, writable: false }, /** * ... recursive arraylike flatten. given parameter arr, return * - if arr is arraylike, a 1-d Array containing the elements of arr with their order preserved, or * - if arr isn't arraylike, arr * * @param {arraylike} arr * @return {arraylike|?} */ '...': { enumerable: true, value: (() =&gt; { let code = '...' let base = [] let desc = 'flatten' return Object.assign( function flatten (arr) { if (!Foft.ISARRAYLIKE(arr)) { return arr } else { return arr.reduce((acc, v) =&gt; { return (Foft.ISARRAYLIKE(v)) ? acc.concat(flatten(v)) : acc.concat(v) }, base) } }, { code, base, desc } ) })(), configurable: false, writable: false }, /** * @name magest - given some * - calculable values, return the one with the greatest MAGNITUDE * - arraylike values, return the one with the greatest MAGEST * * @memberof OPS * @params {(number|Array&lt;number&gt;)} arguments * @return {(number|Array&lt;number&gt;)} */ 'magest': { enumerable: true, value: (() =&gt; { let code = 'magest' let base = 0 let desc = 'greatest magnitude' return Object.assign( function (...args) { let max = base if ([...arguments].every(Foft.ISARRAYLIKE) &amp;&amp; (arguments.length &gt; 1)) { let maxmagest = base let magesti = base for (let i = 0; i &lt; arguments.length; i++) { let cur = Foft.OPS['magest'](...arguments[i]) // console.log(cur) if (cur &gt; maxmagest) { maxmagest = cur magesti = i } } return arguments[magesti] } else if (Foft.ARECALCULABLES(...arguments)) { for (var i = 0; i &lt; arguments.length; i++) { let cur = Math.abs(arguments[i]) max = (cur &gt; max) ? cur : max } return max } else { return NaN } }, { code, base, desc } ) })(), configurable: false, writable: false }, /** * @name magesti - given some values, return the first INDEX of the one with the greatest MAGEST * * @memberof OPS * @params {(number|Array&lt;number&gt;)} * @return {number} */ 'magesti': { enumerable: true, value: (() =&gt; { let code = 'magesti' let base = 0 let desc = 'index of greatest magnitude' return Object.assign( function () { let magests = Array(arguments.length) for (let i = 0; i &lt; arguments.length; i++) { let a = arguments[i] magests[i] = (Foft.ISARRAYLIKE(a)) ? Foft.OPS['magest'](...a) : Foft.OPS['magest'](a) } let index = magests.findIndex((v) =&gt; { // console.log(v) return Foft.EQUAL( v, Foft.OPS['magest'](...magests) ) }) return index }, { code, base, desc } ) })(), configurable: false, writable: false } }), enumerable: true, configurable: false, writable: false }, /** * @static R - dimensional labeling * @memberof Foft */ 'R': { value: ['x', 'y', 'z'], enumerable: true, configurable: false, writable: false }, /** * @static FUNCKEYS - methods for inter-instance communication * @see TTHIS_TEMPLATE * @memberof Foft */ 'FUNCKEYS': { value: [ 'normalizeT', 'antinormalizeT', 'i' ], enumerable: true, configurable: false, writable: false }, /** * @static MEMBERKEYS - members for inter-instance communication * @see TTHIS_TEMPLATE * @memberof Foft */ 'MEMBERKEYS': { value: [ 'range', 'drange', 't0', 'segmentDivisor' ], enumerable: true, configurable: false, writable: false }, /** * @static DEFAULT_SEGMENT_DIVISOR By default, Foft instances divide into * this many segments * @type {Number} * @memberof Foft * @default 10 */ 'DEFAULT_SEGMENT_DIVISOR': { value: 10, enumerable: true, configurable: false, writable: false }, /** * @static MAX_SAFE_DIVISOR the maximum safe to use divisor * @borrows Foft.CALC_PRECISION_WARN * @memberof Foft */ 'MAX_SAFE_DIVISOR': { value: Foft.CALC_PRECISION_WARN(), enumerable: true, configurable: false, writable: false }, /** * @static DEFAULT_RANGE By default, Foft instances evaluate functions over this range * @type {Array.&lt;Number&gt;} * @default [-1,1] * @memberof Foft */ 'DEFAULT_RANGE': { value: [-1, 1], enumerable: true, configurable: false, writable: false } }) export { Foft } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Documentation Classes Foft Global \"...\" Global Members \"...\" ... recursive arraylike flatten. given parameter arr, return if arr is arraylike, a 1-d Array containing the elements of arr with their order preserved, or if arr isn't arraylike, arr Source: foft.js, line 1457 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes Foft Global \"...\" Classes Classes Foft × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes Foft Global \"...\" — foft — Documentation Syntactic sugar for discontinuous (mathematical) functions. It Is A lot of syntactic sugar For investigating the results of known arithmetic expressions provided as functions in JavaScript over specified evaluation ranges, For investigating floating-point error tendencies in a JavaScript environment, and An ECMAScript module for browsers or nodejs. It Is not Fast, A comprehensive calculator, Immune to inaccuracies, A computer algebra system, An equation solver, or An expression parser. Usage: Foft exports a single class, Foft that can create an instance as well as provide some static utilities. Example: import {Foft} from 'foftjs'; m = new Foft({ terms: [t =&gt; 2*t], range: [0, 10], segmentDivisor: 10 //one less than resultant number of evaluation points }); [...m] // Array(11) [ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 ] m(5.13) // 10.26 Generally, a Foft instance can evaluate: Its terms: Function or Foft instances that should generally receive and return Numbers Arrays of Numbers, Nested Arrays of Numbers, or TypedArrays. Some of the properties of its terms(1). Development Guidelines Testing in nodejs Run npm test Documentation Run npm run-script docs × Search results Close "},"Foft.html":{"id":"Foft.html","title":"Class: Foft","body":" Documentation Classes Foft Global \"...\" Class: Foft Foft Foft is a class that evaluates the properties of Function or Foft objects that generally receive and return objects of type Number Array of Number, Array of Array new Foft(params) constructor - create a Foft instance that evaluates its Function terms when given some parameter \"t\". Parameters: Name Type Description params Object | function | Array Properties Name Type Argument Default Description range Number | Array.&lt;Number&gt; &lt;optional&gt; Range of two numerical values over which t is evaluated inclusively. If given a single number t0, range is [-t0,t0] segmentDivisor Number &lt;optional&gt; The number of segments to divide the range into when picking t values for evaluation. terms function | Array.&lt;function()&gt; | Array.&lt;Foft&gt; &lt;optional&gt; [] A function that accepts a parameter t and returns a result of some operation on t rangeoverride boolean &lt;optional&gt; false if true, will override any range provided and set range equal to [0, params.segmentDivisor] harmonize boolean &lt;optional&gt; false if true, will harmonize the domains of any Foft terms to that of the new parent instance @see range, @see segmentDivisor Source: foft.js, line 37 See: Foft.oft Throws: TypeError Examples // returns a Foft instance let MoT = new Foft() // returns a Foft instance that // describes an equation over the range [0,1] (inclusive) // split into 22 segments (23) total points let MoT = new Foft({ range: [0, 1], segmentDivisor: 22, terms: (t) =&gt; t*2; }); Foft also evaluates some of the properties of the Function or Foft objects in its terms Members &lt;static&gt; DEFAULT_RANGE :Array.&lt;Number&gt; Type: Array.&lt;Number&gt; Default Value: [-1,1] Source: foft.js, line 1655 &lt;static&gt; DEFAULT_SEGMENT_DIVISOR :Number Type: Number Default Value: 10 Source: foft.js, line 1632 &lt;static&gt; FUNCKEYS Source: foft.js, line 1599 See: TTHIS_TEMPLATE &lt;static&gt; MATHTYPES Source: foft.js, line 1258 See: Foft.MATHTYPEOF &lt;static&gt; MAX_SAFE_DIVISOR Source: foft.js, line 1643 &lt;static&gt; MEMBERKEYS Source: foft.js, line 1614 See: TTHIS_TEMPLATE &lt;static&gt; OPDICT Source: foft.js, line 1278 See: Foft.OPS &lt;static&gt; OPS Source: foft.js, line 1294 See: Foft.ISOP Foft.OPDICT Foft.OPPARSE Foft.ARENUMBERS &lt;static&gt; R Source: foft.js, line 1588 dabsrange get dabsrange - the absolute value of the delta between the first and final values of the evaluation range Source: foft.js, line 317 drange get drange - the delta between the the first and final values of the evaluation range Source: foft.js, line 308 dt get dt - get the delta for t between the first and final values of the evaluation range. May be innacurate when the range has more than two terms Source: foft.js, line 198 numSegments get numSegments - The number of actual segments the Foft divides the evaluation range into Source: foft.js, line 187 ofAlltT get ofAlltT - get a Generator that yields all Array=[t, this.oft(t)] for t in evaluation range in form [t, this.oft(t)] Source: foft.js, line 681 See: oft ofAlltTOp get ofAlltTOp - get a Generator that yields all this.oftOp(_t, _acc, _op) for _t in T, _acc, _op provided by user Source: foft.js, line 712 See: ofAlltTOp ofFirstt get ofFirstt - return the oft for the first t in the evaluation range Source: foft.js, line 532 See: t0 oft ofLastt get ofLastt - return the oft for the final t in the evaluation range Source: foft.js, line 542 See: range oft opcode get opcode - a Foft can have an opcode as defined in Foft.OPS. These codes represent mathematical operations between Numbers and other types. They are useful for performing said operations when the Function or Foft in the terms Array Source: foft.js, line 253 See: Foft.OPS terms opcode set opcode - set the opcode to one of the opcodes defined in Foft.OPS Source: foft.js, line 263 range set range - only accepts an arraylike of calculables Source: foft.js, line 207 range get range - the evaluation range is the minimum and maximum values for t Source: foft.js, line 220 segmentDivisor set segmentDivisor - set the segment divisor for the evaluation range where the range will be divided into (segmentDivisor+1) segments, if given an arraylike parameter, use the 0th value if given a calculable parameter, use it as-is Source: foft.js, line 160 segmentDivisor get segmentDivisor The number of segment divisors (number of t evaluation points -1) in this Foft Source: foft.js, line 178 T get T - get a Generator yielding all values of t across instance evaluation range Source: foft.js, line 369 Example // get the default t values for which a Foft is // evaluated let MoT = new Foft({ range: [0, Math.PI*2], segmentDivisor: 22, terms: (t) =&gt; [sin(t), cos(t)]; }); let T = [...MoT.T()] t0 get t0 - the first value of t in the evaluation range T Source: foft.js, line 229 See: T terms get terms - the Function terms of this Foft object Source: foft.js, line 109 tt get tt - the last value of t in the evaluation range T Source: foft.js, line 238 See: T Methods &lt;static&gt; ANTINORMALIZETORANGE( [t] [, TT]) Parameters: Name Type Argument Default Description t number &lt;optional&gt; 0 the t to evaluate TT Array.&lt;number&gt; &lt;optional&gt; DEFAULT_RANGE the range in which to test for TT Source: foft.js, line 1044 See: NORMALIZETORANGE Returns: Type number &lt;static&gt; ARECALCULABLES() Source: foft.js, line 925 See: ARENUMBERS Returns: Type boolean &lt;static&gt; ARENUMBERS() Source: foft.js, line 897 See: ARECALCULABLES Returns: Type boolean &lt;static&gt; CALC_PRECISION_WARN() Source: foft.js, line 784 Returns: the object with primitive values: {number} the maximum value for which no precision is lost {string} as brief message Type object &lt;static&gt; DIMENSIONS(x) Parameters: Name Type Description x number | Array the structure to get dimensions of Source: foft.js, line 1088 Returns: Type Array &lt;static&gt; EQUAL() Source: foft.js, line 1147 Returns: Type boolean &lt;static&gt; IINRANGE(t, TT, d) Parameters: Name Type Description t number t to find in TT TT Array.&lt;number&gt; range d type divisor Source: foft.js, line 1070 Returns: Type null | number &lt;static&gt; INRANGE(n [, m] [, mm]) Parameters: Name Type Argument Description n Number the number to test m Number | Array.&lt;Number&gt; &lt;optional&gt; the end of the range starting with 0, or the Array representing the range [m[0], m[last]] the begining of range ending in mm, or mm Number &lt;optional&gt; the optional end of the range Source: foft.js, line 953 Returns: Type boolean &lt;static&gt; ISARRAYLIKE(x) Parameters: Name Type Description x ? Source: foft.js, line 878 Returns: Type boolean &lt;static&gt; ISCALCULABLE() Source: foft.js, line 863 See: ISNUMBER Returns: description Type boolean &lt;static&gt; ISNUMBER() Source: foft.js, line 847 Returns: Type boolean &lt;static&gt; ISOP(codeToParse) Parameters: Name Type Description codeToParse string Source: foft.js, line 1233 See: Foft.OPDICT Returns: Type boolean &lt;static&gt; MATHTYPEOF( [a]) Parameters: Name Type Argument Description a ? &lt;optional&gt; Source: foft.js, line 1185 Returns: Type Symbol | null &lt;static&gt; NORMALIZETORANGE( [t] [, TT] [, NN]) Parameters: Name Type Argument Default Description t number &lt;optional&gt; 0 the t to evaluate TT Array.&lt;number&gt; &lt;optional&gt; DEFAULT_RANGE the range in which to test for TT NN Array.&lt;number&gt; &lt;optional&gt; DEFAULT_RANGE the target normalization range * @return {number} Source: foft.js, line 999 &lt;static&gt; OPPARSE(codeToParse) Parameters: Name Type Description codeToParse string Source: foft.js, line 1245 See: Foft.OPS Returns: Foft.OPS function corresponding to op Type function &lt;static&gt; TTHIS_TEMPLATE(t, foft) Parameters: Name Type Description t Number the t of the instance communicatiing foft Foft the instance doing communication Source: foft.js, line 1203 See: oft Returns: communication object, or array of communication keys Type object | Array.&lt;string&gt; addTerm(term [, harmonize]) addTerm - add a term to the terms of this Foft instance Parameters: Name Type Argument Default Description term function | Foft A Function that takes a parameter (t) or Foft harmonize boolean &lt;optional&gt; false if true, and term is a Foft instance, this overwrites the range and segmentDivisor of term to make them reference the same-named parameters of this instance. Source: foft.js, line 123 Returns: true if length of terms grew Type boolean antinormalizeT(t) antinormalizeT - given a number t return a normalized representation of the ratio of a quantity n to the delta of the instance evaluation range such that the ratio of t to the delta of the evaluation range N satisfies 1.n = maximum normal - N This is the remaining range for the normalized value provided by normalizeT if t falls beyond the lower bound of the evaluation range, return +Infinity if t falls beyond the upper bound of the evaluation range, return -Infinity Parameters: Name Type Description t number Source: foft.js, line 432 See: normalizeT Returns: n Type number dSubrange( [n] [, nn]) get dSubrange - given indices n &amp; nn returns the delta between sub values in the Foft instance's evaluation range, or: range[nn%range.length]-range[n%range.length], when given no parameters, it uses 0 and 1 Parameters: Name Type Argument Default Description n Number &lt;optional&gt; 0 the starting range index. nn Number &lt;optional&gt; n+1%this.range.length the end range index Source: foft.js, line 281 Throws: when given non-number parameter Type TypeError Returns: Type Number i(t) i - given a Number t within a the evaluation range of this instance (inclusive), return the value of the corresponding i such that i is proportional to the location of t within the range i is scaled to segmentDivisor If t falls out of bounds of the range, nothing is returned If the range has more than two elements, return an array of length range-1 Parameters: Name Type Description t Number Source: foft.js, line 451 See: IINRANGE segmentDivisor normalizeT Returns: [0, segmentDivisor] Type Number | null | Array.&lt;(number|null)&gt; isInRange(t) isInRange - return true IFF a given t falls within the evaluation range of this instance Parameters: Name Type Description t number Source: foft.js, line 470 Returns: Type boolean mapT( [callback] [, thisArg]) map - apply the Array.map native function to the elements yielded by this[Symbol.iterator] with the given callback function and this argument * Parameters: Name Type Argument Description callback function &lt;optional&gt; callback to apply thisArg Object &lt;optional&gt; this argument Source: foft.js, line 727 See: get [Symbol.iterator] Returns: map result Type Array mapTOp( [callback] [, thisArg]) mapTOp - apply the Array.map native function to the elements of this.ofAllTOp() with the given callback function and this argument Parameters: Name Type Argument Description callback function &lt;optional&gt; callback to apply thisArg Object &lt;optional&gt; this argument Source: foft.js, line 741 See: Array.map ofAllTOp Returns: map result Type Array normalizeT( [t] [, doAnti]) normalizeT - given a Number t, return a normalized (to Foft.DEFAULT_RANGE) representation of the ratio between t and the delta of the evaluation range of this Foft If t falls out of bounds of range, the value is returned as -/+ Infinity If the evaluation range has more than two values, e.g. [0,1,2], then normalizeT checks in each subrange, e.g. [0,1], [1,2] and returns an Array of normalized values corresponding to each range Parameters: Name Type Argument Default Description t Number &lt;optional&gt; 0 doAnti boolean &lt;optional&gt; false Source: foft.js, line 400 See: NORMALIZETORANGE DEFAULT_RANGE Returns: Type Number | Array.&lt;Number&gt; oft( [t] [, filterNulls] [, maketthis]) oft - evaluate all of the terms held by this Mathoft for the given t value. When evaluating a Function or Foft term, the function or Foft is called with a this object containing certain useful data regarding the calling instance's evaluation of t @see TTHIS_TEMPLATE When evaluating a Foft term, any t that falls outside that term's evaluation range will produce a null result. If the filterNulls parameter is true, then null values will be stripped from the returned result. Parameters: Name Type Argument Default Description t Number &lt;optional&gt; t0 filterNulls boolean &lt;optional&gt; false maketthis boolean &lt;optional&gt; true Source: foft.js, line 486 See: isInRange Returns: Type Number | Array.&lt;Number&gt; | Array.&lt;Array&gt; oftNormal( [tNormal]) oftNormal - Accepts a Number tNormal that falls within Foft.DEFAULT_RANGE, inclusive, and when provided 1 . A NaN value, return NaN 2. +Infinity, returns evaluation from end bound of range 3. -Infinity, returns evaluation from start bound of range 4. Any other number even outside of normal range, returns value of that t. Parameters: Name Type Argument Default Description tNormal Number &lt;optional&gt; [-1,1] Source: foft.js, line 561 See: ISCALCULABLE ofFirstt ofLastt DEFAULT_RANGE oft Returns: Type Number | Array.&lt;Number&gt; oftOp(t [, _op] [, _acc]) oftOp - Calculate the value of performing an operation _op on the values returned by calculating this Foft instance's terms for some evaluation value t. When given a parameter _acc, the calculation of _op will use _acc as its starting value. This is intended to facilitate convenient manipulation of terms and results. Parameters: Name Type Argument Default Description t Number the t to evaluate _op string &lt;optional&gt; this.opcode an opcode to perform @see Foft.OPS _acc Number | Array.&lt;Number&gt; | Array.&lt;Array&gt; &lt;optional&gt; null an accumulator value to start with @see Foft.OPS -&gt; base Source: foft.js, line 595 See: oft Returns: Type Number | Array.&lt;Number&gt; | Array.&lt;Array&gt; subT( [n]) subT - get a generator function that yields segmentDivisor+1 values of t spanning the range [this.range[n], this.range[n+1]], where if n or n+1 fall beyond the bounds of this.range.length, they are constrained to fit Parameters: Name Type Argument Default Description n Number &lt;optional&gt; 0 integer start index of range Source: foft.js, line 330 Returns: description Type type toString() toString Source: foft.js, line 752 Returns: Type string × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
